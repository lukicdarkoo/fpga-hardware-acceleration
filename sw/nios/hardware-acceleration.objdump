
hardware-acceleration.elf:     file format elf32-littlenios2
hardware-acceleration.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00040188

Program Header:
    LOAD off    0x00001000 vaddr 0x00040000 paddr 0x00040000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x00040020 paddr 0x00040020 align 2**12
         filesz 0x000021cc memsz 0x000021cc flags r-x
    LOAD off    0x000031ec vaddr 0x000421ec paddr 0x000422e0 align 2**12
         filesz 0x000000f4 memsz 0x000000f4 flags rw-
    LOAD off    0x000033d4 vaddr 0x000423d4 paddr 0x000423d4 align 2**12
         filesz 0x00000000 memsz 0x0000011c flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00040000  00040000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000168  00040020  00040020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00001d18  00040188  00040188  00001188  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       0000034c  00041ea0  00041ea0  00002ea0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       000000f4  000421ec  000422e0  000031ec  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          0000011c  000423d4  000423d4  000033d4  2**2
                  ALLOC, SMALL_DATA
  6 .onchip_memory2_0 00000000  000424f0  000424f0  000032e0  2**0
                  CONTENTS
  7 .comment      00000023  00000000  00000000  000032e0  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00000498  00000000  00000000  00003308  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   00005e4a  00000000  00000000  000037a0  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 0000215b  00000000  00000000  000095ea  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   000024b8  00000000  00000000  0000b745  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  00000714  00000000  00000000  0000dc00  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    000019b6  00000000  00000000  0000e314  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    000030bc  00000000  00000000  0000fcca  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_alt_sim_info 00000010  00000000  00000000  00012d88  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 000004b8  00000000  00000000  00012d98  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .thread_model 00000003  00000000  00000000  000148ae  2**0
                  CONTENTS, READONLY
 18 .cpu          0000000c  00000000  00000000  000148b1  2**0
                  CONTENTS, READONLY
 19 .qsys         00000001  00000000  00000000  000148bd  2**0
                  CONTENTS, READONLY
 20 .simulation_enabled 00000001  00000000  00000000  000148be  2**0
                  CONTENTS, READONLY
 21 .stderr_dev   0000000b  00000000  00000000  000148bf  2**0
                  CONTENTS, READONLY
 22 .stdin_dev    0000000b  00000000  00000000  000148ca  2**0
                  CONTENTS, READONLY
 23 .stdout_dev   0000000b  00000000  00000000  000148d5  2**0
                  CONTENTS, READONLY
 24 .sopc_system_name 0000000a  00000000  00000000  000148e0  2**0
                  CONTENTS, READONLY
 25 .quartus_project_dir 00000049  00000000  00000000  000148ea  2**0
                  CONTENTS, READONLY
 26 .jdi          00005089  00000000  00000000  00014933  2**0
                  CONTENTS, READONLY
 27 .sopcinfo     00049fb4  00000000  00000000  000199bc  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00040000 l    d  .entry	00000000 .entry
00040020 l    d  .exceptions	00000000 .exceptions
00040188 l    d  .text	00000000 .text
00041ea0 l    d  .rodata	00000000 .rodata
000421ec l    d  .rwdata	00000000 .rwdata
000423d4 l    d  .bss	00000000 .bss
000424f0 l    d  .onchip_memory2_0	00000000 .onchip_memory2_0
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 /home/lukicdarkoo/EPFL/real-time-embedded-systems/acceleration/sw/hardware-acceleration_bsp//obj/HAL/src/crt0.o
000401c0 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 hello_world_small.c
000401c4 l     F .text	0000005c shift
00040220 l     F .text	00000034 accelerator_irq
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 vfprintf.c
000408f0 l     F .text	0000006c print_repeat
00000000 l    df *ABS*	00000000 fvwrite_small_dev.c
00000000 l    df *ABS*	00000000 impure.c
000421ec l     O .rwdata	000000e0 impure_data
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_load.c
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_printf.c
00000000 l    df *ABS*	00000000 alt_putchar.c
00000000 l    df *ABS*	00000000 alt_write.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_performance_counter.c
00000000 l    df *ABS*	00000000 perf_print_formatted_report.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
000423ec g     O .bss	00000004 alt_instruction_exception_handler
0004133c g     F .text	0000002c alt_main
00040840 g     F .text	00000080 _puts_r
000423f0 g     O .bss	00000100 alt_irq
000422e0 g       *ABS*	00000000 __flash_rwdata_start
00040540 g     F .text	00000218 csv_export
000407f4 g     F .text	0000004c printf
00041630 g     F .text	0000000c alt_get_cpu_freq
0004163c g     F .text	00000210 perf_print_formatted_report
000418c0 g     F .text	00000008 altera_nios2_gen2_irq_init
000402e8 g     F .text	00000258 perfomance_test
00040000 g     F .entry	0000000c __reset
00040020 g       *ABS*	00000000 __flash_exceptions_start
000423d8 g     O .bss	00000004 errno
000423e4 g     O .bss	00000004 alt_argv
0004a2cc g       *ABS*	00000000 _gp
00040790 g     F .text	00000028 memcpy
000408c0 g     F .text	00000014 puts
0004184c g     F .text	00000074 alt_exception_cause_generated_bad_addr
000407b8 g     F .text	0000003c _printf_r
00040000 g       *ABS*	00000000 __alt_mem_onchip_memory2_0
000410a4 g     F .text	00000064 .hidden __udivsi3
00041610 g     F .text	00000014 perf_get_num_starts
000422cc g     O .rwdata	00000004 _global_impure_ptr
000424f0 g       *ABS*	00000000 __bss_end
000411f4 g     F .text	00000068 alt_iic_isr_register
00041928 g     F .text	00000578 .hidden __udivdi3
000411dc g     F .text	00000018 alt_ic_irq_enabled
000423dc g     O .bss	00000004 alt_irq_active
000400fc g     F .exceptions	00000060 alt_irq_handler
00041160 g     F .text	00000004 alt_dcache_flush_all
000422e0 g       *ABS*	00000000 __ram_rwdata_end
00041520 g     F .text	00000060 write
000421ec g       *ABS*	00000000 __ram_rodata_end
000422d8 g     O .rwdata	00000004 jtag_uart_0
00041108 g     F .text	00000058 .hidden __umodsi3
000424f0 g       *ABS*	00000000 end
0004015c g     F .exceptions	0000002c alt_instruction_exception_entry
00080000 g       *ABS*	00000000 __alt_stack_pointer
000415b4 g     F .text	00000034 altera_avalon_jtag_uart_write
0004095c g     F .text	00000524 ___vfprintf_internal_r
00041368 g     F .text	00000170 alt_printf
00040188 g     F .text	0000003c _start
000415a0 g     F .text	00000014 alt_sys_init
000421ec g       *ABS*	00000000 __ram_rwdata_start
00041ea0 g       *ABS*	00000000 __ram_rodata_start
000415e8 g     F .text	00000020 perf_get_section_time
000424f0 g       *ABS*	00000000 __alt_stack_base
00041608 g     F .text	00000008 perf_get_total_time
00040e9c g     F .text	000000b8 __sfvwrite_small_dev
000423d4 g       *ABS*	00000000 __bss_start
00040758 g     F .text	00000038 main
000423e0 g     O .bss	00000004 alt_envp
000422dc g     O .rwdata	00000004 alt_errno
00040fac g     F .text	00000084 .hidden __divsi3
00041ea0 g       *ABS*	00000000 __flash_rodata_start
00041580 g     F .text	00000020 alt_irq_init
000420ec g     O .rodata	00000100 .hidden __clz_tab
00040f54 g     F .text	00000058 _write_r
000422d0 g     O .rwdata	00000004 _impure_ptr
000423e8 g     O .bss	00000004 alt_argc
00040254 g     F .text	00000094 correctness_test
00040020 g       .exceptions	00000000 alt_irq_entry
00040020 g       *ABS*	00000000 __ram_exceptions_start
00041168 g     F .text	00000004 alt_ic_isr_register
000422e0 g       *ABS*	00000000 _edata
000424f0 g       *ABS*	00000000 _end
00040188 g       *ABS*	00000000 __ram_exceptions_end
000411a4 g     F .text	00000038 alt_ic_irq_disable
00041624 g     F .text	0000000c alt_get_performance_counter_base
00041030 g     F .text	00000074 .hidden __modsi3
00080000 g       *ABS*	00000000 __alt_data_end
00040020 g     F .exceptions	00000000 alt_exception
0004000c g       .entry	00000000 _exit
000418c8 g     F .text	00000060 .hidden __muldi3
000423d4 g     O .bss	00000004 acclerator_done
000408d4 g     F .text	0000001c strlen
000414d8 g     F .text	00000048 alt_putchar
00041164 g     F .text	00000004 alt_icache_flush_all
000422d4 g     O .rwdata	00000004 alt_priority_mask
0004116c g     F .text	00000038 alt_ic_irq_enable
00040e80 g     F .text	0000001c __vfprintf_internal
0004125c g     F .text	000000e0 alt_load



Disassembly of section .entry:

00040000 <__reset>:
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
   40000:	00400134 	movhi	at,4
    ori r1, r1, %lo(_start)
   40004:	08406214 	ori	at,at,392
    jmp r1
   40008:	0800683a 	jmp	at

0004000c <_exit>:
	...

Disassembly of section .exceptions:

00040020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
   40020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
   40024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
   40028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
   4002c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
   40030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
   40034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
   40038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
   4003c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
   40040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
   40044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
   40048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
   4004c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
   40050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
   40054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
   40058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
   4005c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
   40060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
   40064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
   40068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
   4006c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
   40070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
   40074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
   40078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
   4007c:	10000326 	beq	r2,zero,4008c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
   40080:	20000226 	beq	r4,zero,4008c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
   40084:	00400fc0 	call	400fc <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
   40088:	00000706 	br	400a8 <alt_exception+0x88>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
   4008c:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
   40090:	e8bfff17 	ldw	r2,-4(ea)
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
   40094:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
   40098:	004015c0 	call	4015c <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
   4009c:	1000021e 	bne	r2,zero,400a8 <alt_exception+0x88>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
   400a0:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
   400a4:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
   400a8:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
   400ac:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
   400b0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
   400b4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
   400b8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
   400bc:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
   400c0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
   400c4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
   400c8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
   400cc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
   400d0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
   400d4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
   400d8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
   400dc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
   400e0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
   400e4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
   400e8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
   400ec:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
   400f0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
   400f4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
   400f8:	ef80083a 	eret

000400fc <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
   400fc:	defffe04 	addi	sp,sp,-8
   40100:	dfc00115 	stw	ra,4(sp)
   40104:	dc000015 	stw	r16,0(sp)
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
   40108:	0009313a 	rdctl	r4,ipending
    do
    {
      if (active & mask)
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
   4010c:	04000134 	movhi	r16,4
   40110:	8408fc04 	addi	r16,r16,9200

  active = alt_irq_pending ();

  do
  {
    i = 0;
   40114:	0005883a 	mov	r2,zero
    mask = 1;
   40118:	00c00044 	movi	r3,1
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
   4011c:	20ca703a 	and	r5,r4,r3
   40120:	28000b26 	beq	r5,zero,40150 <alt_irq_handler+0x54>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
   40124:	100490fa 	slli	r2,r2,3
   40128:	8085883a 	add	r2,r16,r2
   4012c:	10c00017 	ldw	r3,0(r2)
   40130:	11000117 	ldw	r4,4(r2)
   40134:	183ee83a 	callr	r3
   40138:	0009313a 	rdctl	r4,ipending

    } while (1);

    active = alt_irq_pending ();
    
  } while (active);
   4013c:	203ff51e 	bne	r4,zero,40114 <alt_irq_handler+0x18>
  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
}
   40140:	dfc00117 	ldw	ra,4(sp)
   40144:	dc000017 	ldw	r16,0(sp)
   40148:	dec00204 	addi	sp,sp,8
   4014c:	f800283a 	ret
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
   40150:	18c7883a 	add	r3,r3,r3
      i++;
   40154:	10800044 	addi	r2,r2,1

    } while (1);
   40158:	003ff006 	br	4011c <alt_irq_handler+0x20>

0004015c <alt_instruction_exception_entry>:
 * NIOS2_EXCEPTION_CAUSE_NOT_PRESENT. Your handling routine should
 * check the validity of the cause argument before proceeding.
 */
#ifdef NIOS2_HAS_EXTRA_EXCEPTION_INFO
  /* Get exception cause & "badaddr" */
  NIOS2_READ_EXCEPTION(cause);
   4015c:	000531fa 	rdctl	r2,exception
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
   40160:	000d333a 	rdctl	r6,badaddr
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  badaddr = 0;
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
   40164:	d0e04817 	ldw	r3,-32480(gp)
   40168:	18000426 	beq	r3,zero,4017c <alt_instruction_exception_entry+0x20>
 * check the validity of the cause argument before proceeding.
 */
#ifdef NIOS2_HAS_EXTRA_EXCEPTION_INFO
  /* Get exception cause & "badaddr" */
  NIOS2_READ_EXCEPTION(cause);
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
   4016c:	10801f0c 	andi	r2,r2,124
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
   40170:	200b883a 	mov	r5,r4
   40174:	1008d0ba 	srli	r4,r2,2
   40178:	1800683a 	jmp	r3
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
   4017c:	003da03a 	break	0
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
}
   40180:	0005883a 	mov	r2,zero
   40184:	f800283a 	ret

Disassembly of section .text:

00040188 <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
   40188:	06c00234 	movhi	sp,8
    ori sp, sp, %lo(__alt_stack_pointer)
   4018c:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
   40190:	06800134 	movhi	gp,4
    ori gp, gp, %lo(_gp)
   40194:	d6a8b314 	ori	gp,gp,41676
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
   40198:	00800134 	movhi	r2,4
    ori r2, r2, %lo(__bss_start)
   4019c:	1088f514 	ori	r2,r2,9172

    movhi r3, %hi(__bss_end)
   401a0:	00c00134 	movhi	r3,4
    ori r3, r3, %lo(__bss_end)
   401a4:	18c93c14 	ori	r3,r3,9456

    beq r2, r3, 1f
   401a8:	10c00326 	beq	r2,r3,401b8 <_start+0x30>

0:
    stw zero, (r2)
   401ac:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
   401b0:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
   401b4:	10fffd36 	bltu	r2,r3,401ac <_start+0x24>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
   401b8:	004125c0 	call	4125c <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
   401bc:	004133c0 	call	4133c <alt_main>

000401c0 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
   401c0:	003fff06 	br	401c0 <alt_after_alt_main>

000401c4 <shift>:
}

inline static int shift(int a) {
	int b = 0;
	b |= (a & 0x000000FF) << 24;
	b |= (a & 0xFF000000) >> 24;
   401c4:	2006d63a 	srli	r3,r4,24
   401c8:	2004963a 	slli	r2,r4,24
	for (int i = 0; i < 8; i++) {
		b |= (a & (1 << (i + 16))) >> (2 * i + 1);
		b |= (a & (1 << (i + 8))) << (15 - i * 2);
   401cc:	02000044 	movi	r8,1

inline static int shift(int a) {
	int b = 0;
	b |= (a & 0x000000FF) << 24;
	b |= (a & 0xFF000000) >> 24;
	for (int i = 0; i < 8; i++) {
   401d0:	02400604 	movi	r9,24
}

inline static int shift(int a) {
	int b = 0;
	b |= (a & 0x000000FF) << 24;
	b |= (a & 0xFF000000) >> 24;
   401d4:	1884b03a 	or	r2,r3,r2
   401d8:	00c00404 	movi	r3,16
	for (int i = 0; i < 8; i++) {
		b |= (a & (1 << (i + 16))) >> (2 * i + 1);
		b |= (a & (1 << (i + 8))) << (15 - i * 2);
   401dc:	19fffe04 	addi	r7,r3,-8
   401e0:	41ce983a 	sll	r7,r8,r7
   401e4:	00cbc83a 	sub	r5,zero,r3
   401e8:	294b883a 	add	r5,r5,r5
   401ec:	390c703a 	and	r6,r7,r4
   401f0:	29400bc4 	addi	r5,r5,47
   401f4:	314e983a 	sll	r7,r6,r5
   401f8:	40cc983a 	sll	r6,r8,r3
   401fc:	18cb883a 	add	r5,r3,r3
   40200:	297ff844 	addi	r5,r5,-31
   40204:	310c703a 	and	r6,r6,r4
   40208:	314bd83a 	sra	r5,r6,r5
   4020c:	18c00044 	addi	r3,r3,1
   40210:	394ab03a 	or	r5,r7,r5
   40214:	1144b03a 	or	r2,r2,r5

inline static int shift(int a) {
	int b = 0;
	b |= (a & 0x000000FF) << 24;
	b |= (a & 0xFF000000) >> 24;
	for (int i = 0; i < 8; i++) {
   40218:	1a7ff01e 	bne	r3,r9,401dc <shift+0x18>
		b |= (a & (1 << (i + 16))) >> (2 * i + 1);
		b |= (a & (1 << (i + 8))) << (15 - i * 2);
	}
	return b;
}
   4021c:	f800283a 	ret

00040220 <accelerator_irq>:
#define CONFIG_IRQ_ACC 1

volatile int acclerator_done = 0;

static void accelerator_irq(void* context) {
	TOC
   40220:	00c00234 	movhi	r3,8
   40224:	0005883a 	mov	r2,zero
   40228:	18c41404 	addi	r3,r3,4176
   4022c:	18800035 	stwio	r2,0(r3)
   40230:	00c00234 	movhi	r3,8
   40234:	18c41004 	addi	r3,r3,4160
   40238:	18800035 	stwio	r2,0(r3)
	acclerator_done = 1;
   4023c:	00c00044 	movi	r3,1
   40240:	d0e04215 	stw	r3,-32504(gp)
	IOWR_32DIRECT(SWAP_ACCELERATOR_0_BASE, 12, 0);	// Disable interrupt
   40244:	00c00234 	movhi	r3,8
   40248:	18c43704 	addi	r3,r3,4316
   4024c:	18800035 	stwio	r2,0(r3)
   40250:	f800283a 	ret

00040254 <correctness_test>:
	IOWR_32DIRECT(SWAP_ACCELERATOR_0_BASE, 8, 1);	// Start
}

void correctness_test() {
	int a = 0x11F0A0FF;
	unsigned long buffer[] = { a };
   40254:	01047c74 	movhi	r4,4593
	IOWR_32DIRECT(SWAP_ACCELERATOR_0_BASE, 4, length);
	IOWR_32DIRECT(SWAP_ACCELERATOR_0_BASE, 12, 1);	// Enable interrupt
	IOWR_32DIRECT(SWAP_ACCELERATOR_0_BASE, 8, 1);	// Start
}

void correctness_test() {
   40258:	defffd04 	addi	sp,sp,-12
	int a = 0x11F0A0FF;
	unsigned long buffer[] = { a };
   4025c:	21283fc4 	addi	r4,r4,-24321
	IOWR_32DIRECT(SWAP_ACCELERATOR_0_BASE, 4, length);
	IOWR_32DIRECT(SWAP_ACCELERATOR_0_BASE, 12, 1);	// Enable interrupt
	IOWR_32DIRECT(SWAP_ACCELERATOR_0_BASE, 8, 1);	// Start
}

void correctness_test() {
   40260:	dfc00215 	stw	ra,8(sp)
   40264:	dc000115 	stw	r16,4(sp)
	int a = 0x11F0A0FF;
	unsigned long buffer[] = { a };
   40268:	d9000015 	stw	r4,0(sp)

	int res_custom = ALT_CI_SWAP_0(a, 0);
   4026c:	2021c032 	custom	0,r16,r4,zero
	int res_c = shift(a);
   40270:	00401c40 	call	401c4 <shift>
	}
	return b;
}

inline void accelerated_shift(unsigned long *buffer, unsigned short length) {
	IOWR_32DIRECT(SWAP_ACCELERATOR_0_BASE, 0, buffer);
   40274:	00c00234 	movhi	r3,8
   40278:	18c43404 	addi	r3,r3,4304
   4027c:	1ec00035 	stwio	sp,0(r3)
	IOWR_32DIRECT(SWAP_ACCELERATOR_0_BASE, 4, length);
   40280:	01000234 	movhi	r4,8
   40284:	00c00044 	movi	r3,1
   40288:	21043504 	addi	r4,r4,4308
   4028c:	20c00035 	stwio	r3,0(r4)
	IOWR_32DIRECT(SWAP_ACCELERATOR_0_BASE, 12, 1);	// Enable interrupt
   40290:	01000234 	movhi	r4,8
   40294:	21043704 	addi	r4,r4,4316
   40298:	20c00035 	stwio	r3,0(r4)
	IOWR_32DIRECT(SWAP_ACCELERATOR_0_BASE, 8, 1);	// Start
   4029c:	01000234 	movhi	r4,8
   402a0:	21043604 	addi	r4,r4,4312
   402a4:	20c00035 	stwio	r3,0(r4)

	int res_custom = ALT_CI_SWAP_0(a, 0);
	int res_c = shift(a);
	accelerated_shift(buffer, 1);

	alt_printf("Result from C is 0x%x \n", res_c);
   402a8:	01000134 	movhi	r4,4
   402ac:	100b883a 	mov	r5,r2
   402b0:	2107a804 	addi	r4,r4,7840
   402b4:	00413680 	call	41368 <alt_printf>
	alt_printf("Result from custom instruction is 0x%x \n", res_custom);
   402b8:	01000134 	movhi	r4,4
   402bc:	800b883a 	mov	r5,r16
   402c0:	2107ae04 	addi	r4,r4,7864
   402c4:	00413680 	call	41368 <alt_printf>
	alt_printf("Result from accelerator is 0x%x \n", buffer[0]);
   402c8:	d9400017 	ldw	r5,0(sp)
   402cc:	01000134 	movhi	r4,4
   402d0:	2107b904 	addi	r4,r4,7908
   402d4:	00413680 	call	41368 <alt_printf>
}
   402d8:	dfc00217 	ldw	ra,8(sp)
   402dc:	dc000117 	ldw	r16,4(sp)
   402e0:	dec00304 	addi	sp,sp,12
   402e4:	f800283a 	ret

000402e8 <perfomance_test>:

void perfomance_test() {
   402e8:	deffef04 	addi	sp,sp,-68
   402ec:	df000f15 	stw	fp,60(sp)
	int a = 0x11F0A0FF;
	int sample_batches[] = { 1, 100, 1000 };
   402f0:	01400134 	movhi	r5,4
	alt_printf("Result from C is 0x%x \n", res_c);
	alt_printf("Result from custom instruction is 0x%x \n", res_custom);
	alt_printf("Result from accelerator is 0x%x \n", buffer[0]);
}

void perfomance_test() {
   402f4:	df000f04 	addi	fp,sp,60
   402f8:	dcc00a15 	stw	r19,40(sp)
   402fc:	dc800915 	stw	r18,36(sp)
   40300:	dfc01015 	stw	ra,64(sp)
   40304:	ddc00e15 	stw	r23,56(sp)
   40308:	dd800d15 	stw	r22,52(sp)
   4030c:	dd400c15 	stw	r21,48(sp)
   40310:	dd000b15 	stw	r20,44(sp)
   40314:	dc400815 	stw	r17,32(sp)
   40318:	dc000715 	stw	r16,28(sp)
	int a = 0x11F0A0FF;
	int sample_batches[] = { 1, 100, 1000 };
   4031c:	01800304 	movi	r6,12
   40320:	2947ec04 	addi	r5,r5,8112
   40324:	e13ff204 	addi	r4,fp,-56
   40328:	00407900 	call	40790 <memcpy>
   4032c:	0027883a 	mov	r19,zero

	for (int ni = 0; ni < 3; ni++) {
		int n_samples = sample_batches[ni];

		// Custom instruction
		TIC
   40330:	04800044 	movi	r18,1
void perfomance_test() {
	int a = 0x11F0A0FF;
	int sample_batches[] = { 1, 100, 1000 };

	for (int ni = 0; ni < 3; ni++) {
		int n_samples = sample_batches[ni];
   40334:	e0fff204 	addi	r3,fp,-56
   40338:	1cc5883a 	add	r2,r3,r19
   4033c:	15c00017 	ldw	r23,0(r2)

		// Custom instruction
		TIC
   40340:	00800234 	movhi	r2,8
   40344:	10841004 	addi	r2,r2,4160
   40348:	14800035 	stwio	r18,0(r2)
   4034c:	00c00234 	movhi	r3,8
   40350:	18c41104 	addi	r3,r3,4164
   40354:	18000035 	stwio	zero,0(r3)
   40358:	05400234 	movhi	r21,8
   4035c:	ad441504 	addi	r21,r21,4180
   40360:	a8000035 	stwio	zero,0(r21)
   40364:	04400234 	movhi	r17,8
		for (int i = 0; i < n_samples; i++) {
   40368:	0005883a 	mov	r2,zero
   4036c:	8c441004 	addi	r17,r17,4160
   40370:	182d883a 	mov	r22,r3
   40374:	15c0060e 	bge	r2,r23,40390 <perfomance_test+0xa8>
			volatile int res = ALT_CI_SWAP_0(a, 0);
   40378:	00c47c74 	movhi	r3,4593
   4037c:	18e83fc4 	addi	r3,r3,-24321
   40380:	1809c032 	custom	0,r4,r3,zero
   40384:	e13ff615 	stw	r4,-40(fp)
	for (int ni = 0; ni < 3; ni++) {
		int n_samples = sample_batches[ni];

		// Custom instruction
		TIC
		for (int i = 0; i < n_samples; i++) {
   40388:	10800044 	addi	r2,r2,1
   4038c:	003ff906 	br	40374 <perfomance_test+0x8c>
			volatile int res = ALT_CI_SWAP_0(a, 0);
		}
		TOC
   40390:	05000234 	movhi	r20,8
   40394:	a5041404 	addi	r20,r20,4176
   40398:	a0000035 	stwio	zero,0(r20)
   4039c:	88000035 	stwio	zero,0(r17)
		printf("Custom instruction (%d elements)\n", n_samples);
   403a0:	01000134 	movhi	r4,4
   403a4:	b80b883a 	mov	r5,r23
   403a8:	2107c204 	addi	r4,r4,7944
   403ac:	00407f40 	call	407f4 <printf>
		TOC_PRINT
   403b0:	04000134 	movhi	r16,4
   403b4:	8407cc04 	addi	r16,r16,7984
   403b8:	01c00134 	movhi	r7,4
   403bc:	0140bef4 	movhi	r5,763
   403c0:	01000234 	movhi	r4,8
   403c4:	dc000015 	stw	r16,0(sp)
   403c8:	39c7cb04 	addi	r7,r7,7980
   403cc:	01800084 	movi	r6,2
   403d0:	297c2004 	addi	r5,r5,-3968
   403d4:	21041004 	addi	r4,r4,4160
   403d8:	004163c0 	call	4163c <perf_print_formatted_report>

		// C shift
		TIC
   403dc:	8c800035 	stwio	r18,0(r17)
   403e0:	b0000035 	stwio	zero,0(r22)
   403e4:	a8000035 	stwio	zero,0(r21)
		for (int i = 0; i < n_samples; i++) {
   403e8:	000b883a 	mov	r5,zero
   403ec:	2dc0080e 	bge	r5,r23,40410 <perfomance_test+0x128>
			volatile int res = shift(a);
   403f0:	01047c74 	movhi	r4,4593
   403f4:	21283fc4 	addi	r4,r4,-24321
   403f8:	e17ff715 	stw	r5,-36(fp)
   403fc:	00401c40 	call	401c4 <shift>
		printf("Custom instruction (%d elements)\n", n_samples);
		TOC_PRINT

		// C shift
		TIC
		for (int i = 0; i < n_samples; i++) {
   40400:	e17ff717 	ldw	r5,-36(fp)
			volatile int res = shift(a);
   40404:	e0bff515 	stw	r2,-44(fp)
		printf("Custom instruction (%d elements)\n", n_samples);
		TOC_PRINT

		// C shift
		TIC
		for (int i = 0; i < n_samples; i++) {
   40408:	29400044 	addi	r5,r5,1
   4040c:	003ff706 	br	403ec <perfomance_test+0x104>
			volatile int res = shift(a);
		}
		TOC
   40410:	a0000035 	stwio	zero,0(r20)
   40414:	88000035 	stwio	zero,0(r17)
		printf("C function (%d elements)\n", n_samples);
   40418:	01000134 	movhi	r4,4
   4041c:	b80b883a 	mov	r5,r23
   40420:	2107ce04 	addi	r4,r4,7992
   40424:	00407f40 	call	407f4 <printf>
		TOC_PRINT
   40428:	01c00134 	movhi	r7,4
   4042c:	0140bef4 	movhi	r5,763
   40430:	01000234 	movhi	r4,8
   40434:	dc000015 	stw	r16,0(sp)
   40438:	39c7cb04 	addi	r7,r7,7980
   4043c:	01800084 	movi	r6,2
   40440:	297c2004 	addi	r5,r5,-3968
   40444:	21041004 	addi	r4,r4,4160
   40448:	004163c0 	call	4163c <perf_print_formatted_report>

		// Accelerator
		volatile int buffer[n_samples];
   4044c:	bdc5883a 	add	r2,r23,r23
   40450:	1085883a 	add	r2,r2,r2
   40454:	10800184 	addi	r2,r2,6
   40458:	1004d0ba 	srli	r2,r2,2
   4045c:	d811883a 	mov	r8,sp
   40460:	1085883a 	add	r2,r2,r2
   40464:	1085883a 	add	r2,r2,r2
   40468:	d8b7c83a 	sub	sp,sp,r2
   4046c:	d9000104 	addi	r4,sp,4
		TIC
   40470:	8c800035 	stwio	r18,0(r17)
   40474:	b0000035 	stwio	zero,0(r22)
   40478:	a8000035 	stwio	zero,0(r21)
	}
	return b;
}

inline void accelerated_shift(unsigned long *buffer, unsigned short length) {
	IOWR_32DIRECT(SWAP_ACCELERATOR_0_BASE, 0, buffer);
   4047c:	00800234 	movhi	r2,8
   40480:	10843404 	addi	r2,r2,4304
   40484:	11000035 	stwio	r4,0(r2)
	IOWR_32DIRECT(SWAP_ACCELERATOR_0_BASE, 4, length);
   40488:	00800234 	movhi	r2,8
   4048c:	b93fffcc 	andi	r4,r23,65535
   40490:	10843504 	addi	r2,r2,4308
   40494:	11000035 	stwio	r4,0(r2)
	IOWR_32DIRECT(SWAP_ACCELERATOR_0_BASE, 12, 1);	// Enable interrupt
   40498:	00800234 	movhi	r2,8
   4049c:	10843704 	addi	r2,r2,4316
   404a0:	14800035 	stwio	r18,0(r2)
	IOWR_32DIRECT(SWAP_ACCELERATOR_0_BASE, 8, 1);	// Start
   404a4:	00800234 	movhi	r2,8
   404a8:	10843604 	addi	r2,r2,4312
   404ac:	14800035 	stwio	r18,0(r2)

		// Accelerator
		volatile int buffer[n_samples];
		TIC
		accelerated_shift(buffer, n_samples);
		alt_dcache_flush_all();
   404b0:	e23ff715 	stw	r8,-36(fp)
   404b4:	00411600 	call	41160 <alt_dcache_flush_all>
		alt_icache_flush_all();
   404b8:	00411640 	call	41164 <alt_icache_flush_all>
		TOC
   404bc:	a0000035 	stwio	zero,0(r20)
   404c0:	88000035 	stwio	zero,0(r17)
		printf("Accelerated shift (%d elements)\n", n_samples);
   404c4:	01000134 	movhi	r4,4
   404c8:	b80b883a 	mov	r5,r23
   404cc:	2107d504 	addi	r4,r4,8020
   404d0:	00407f40 	call	407f4 <printf>
		TOC_PRINT
   404d4:	01c00134 	movhi	r7,4
   404d8:	0140bef4 	movhi	r5,763
   404dc:	01000234 	movhi	r4,8
   404e0:	dc000015 	stw	r16,0(sp)
   404e4:	39c7cb04 	addi	r7,r7,7980
   404e8:	01800084 	movi	r6,2
   404ec:	297c2004 	addi	r5,r5,-3968
   404f0:	21041004 	addi	r4,r4,4160
   404f4:	004163c0 	call	4163c <perf_print_formatted_report>
   404f8:	e23ff717 	ldw	r8,-36(fp)
   404fc:	9cc00104 	addi	r19,r19,4

void perfomance_test() {
	int a = 0x11F0A0FF;
	int sample_batches[] = { 1, 100, 1000 };

	for (int ni = 0; ni < 3; ni++) {
   40500:	00800304 	movi	r2,12
   40504:	4037883a 	mov	sp,r8
   40508:	98bf8a1e 	bne	r19,r2,40334 <perfomance_test+0x4c>
		alt_icache_flush_all();
		TOC
		printf("Accelerated shift (%d elements)\n", n_samples);
		TOC_PRINT
	}
}
   4050c:	e6fff804 	addi	sp,fp,-32
   40510:	dfc00917 	ldw	ra,36(sp)
   40514:	df000817 	ldw	fp,32(sp)
   40518:	ddc00717 	ldw	r23,28(sp)
   4051c:	dd800617 	ldw	r22,24(sp)
   40520:	dd400517 	ldw	r21,20(sp)
   40524:	dd000417 	ldw	r20,16(sp)
   40528:	dcc00317 	ldw	r19,12(sp)
   4052c:	dc800217 	ldw	r18,8(sp)
   40530:	dc400117 	ldw	r17,4(sp)
   40534:	dc000017 	ldw	r16,0(sp)
   40538:	dec00a04 	addi	sp,sp,40
   4053c:	f800283a 	ret

00040540 <csv_export>:

void csv_export() {
   40540:	deffe604 	addi	sp,sp,-104
   40544:	df001815 	stw	fp,96(sp)
	unsigned int time_custom;
	unsigned int time_c;
	unsigned int time_accelerator;
	int sample_batches[] = { 50000, 10000, 5000, 1000, 500, 100, 50, 10, 5, 1 };
   40548:	01400134 	movhi	r5,4
		printf("Accelerated shift (%d elements)\n", n_samples);
		TOC_PRINT
	}
}

void csv_export() {
   4054c:	df001804 	addi	fp,sp,96
   40550:	dfc01915 	stw	ra,100(sp)
   40554:	dc801215 	stw	r18,72(sp)
   40558:	dc401115 	stw	r17,68(sp)
	unsigned int time_custom;
	unsigned int time_c;
	unsigned int time_accelerator;
	int sample_batches[] = { 50000, 10000, 5000, 1000, 500, 100, 50, 10, 5, 1 };
   4055c:	01800a04 	movi	r6,40
   40560:	2947ef04 	addi	r5,r5,8124
   40564:	e13fe904 	addi	r4,fp,-92
		printf("Accelerated shift (%d elements)\n", n_samples);
		TOC_PRINT
	}
}

void csv_export() {
   40568:	ddc01715 	stw	r23,92(sp)
   4056c:	dd801615 	stw	r22,88(sp)
   40570:	dd401515 	stw	r21,84(sp)
   40574:	dd001415 	stw	r20,80(sp)
   40578:	dcc01315 	stw	r19,76(sp)
   4057c:	dc001015 	stw	r16,64(sp)
	unsigned int time_custom;
	unsigned int time_c;
	unsigned int time_accelerator;
	int sample_batches[] = { 50000, 10000, 5000, 1000, 500, 100, 50, 10, 5, 1 };
   40580:	00407900 	call	40790 <memcpy>

	printf("BatchSize,Custom,CFunction,Accelerator\n");
   40584:	01000134 	movhi	r4,4
   40588:	2107de04 	addi	r4,r4,8056
   4058c:	00408c00 	call	408c0 <puts>
   40590:	0025883a 	mov	r18,zero
	for (int ni = 0; ni < sizeof(sample_batches) / 4; ni++) {
		int n_samples = sample_batches[ni];

		// Custom shift
		TIC
   40594:	04400044 	movi	r17,1
	unsigned int time_accelerator;
	int sample_batches[] = { 50000, 10000, 5000, 1000, 500, 100, 50, 10, 5, 1 };

	printf("BatchSize,Custom,CFunction,Accelerator\n");
	for (int ni = 0; ni < sizeof(sample_batches) / 4; ni++) {
		int n_samples = sample_batches[ni];
   40598:	e0ffe904 	addi	r3,fp,-92
   4059c:	1c85883a 	add	r2,r3,r18
   405a0:	14000017 	ldw	r16,0(r2)

		// Custom shift
		TIC
   405a4:	00800234 	movhi	r2,8
   405a8:	10841004 	addi	r2,r2,4160
   405ac:	14400035 	stwio	r17,0(r2)
   405b0:	00c00234 	movhi	r3,8
   405b4:	18c41104 	addi	r3,r3,4164
   405b8:	18000035 	stwio	zero,0(r3)
   405bc:	00800234 	movhi	r2,8
   405c0:	10841504 	addi	r2,r2,4180
   405c4:	10000035 	stwio	zero,0(r2)
   405c8:	04c00234 	movhi	r19,8
   405cc:	05400234 	movhi	r21,8
		for (int i = 0; i < n_samples; i++) {
   405d0:	0005883a 	mov	r2,zero
   405d4:	9cc41004 	addi	r19,r19,4160
   405d8:	182d883a 	mov	r22,r3
   405dc:	ad441504 	addi	r21,r21,4180
   405e0:	1400040e 	bge	r2,r16,405f4 <csv_export+0xb4>
			volatile int res = ALT_CI_SWAP_0(i, 0);
   405e4:	1007c032 	custom	0,r3,r2,zero
   405e8:	e0fff415 	stw	r3,-48(fp)
	for (int ni = 0; ni < sizeof(sample_batches) / 4; ni++) {
		int n_samples = sample_batches[ni];

		// Custom shift
		TIC
		for (int i = 0; i < n_samples; i++) {
   405ec:	10800044 	addi	r2,r2,1
   405f0:	003ffb06 	br	405e0 <csv_export+0xa0>
			volatile int res = ALT_CI_SWAP_0(i, 0);
		}
		TOC
   405f4:	05000234 	movhi	r20,8
   405f8:	a5041404 	addi	r20,r20,4176
   405fc:	a0000035 	stwio	zero,0(r20)
   40600:	98000035 	stwio	zero,0(r19)
		time_custom = perf_get_total_time(PERFORMANCE_COUNTER_0_BASE);
   40604:	01000234 	movhi	r4,8
   40608:	21041004 	addi	r4,r4,4160
   4060c:	00416080 	call	41608 <perf_get_total_time>
   40610:	e0bff515 	stw	r2,-44(fp)

		// Accelerator
		volatile int buffer[n_samples];
   40614:	8405883a 	add	r2,r16,r16
   40618:	1085883a 	add	r2,r2,r2
   4061c:	10800184 	addi	r2,r2,6
   40620:	1004d0ba 	srli	r2,r2,2
   40624:	e6fff615 	stw	sp,-40(fp)
   40628:	1085883a 	add	r2,r2,r2
   4062c:	1085883a 	add	r2,r2,r2
   40630:	d8b7c83a 	sub	sp,sp,r2
   40634:	d8c00104 	addi	r3,sp,4
		TIC
   40638:	9c400035 	stwio	r17,0(r19)
   4063c:	b0000035 	stwio	zero,0(r22)
   40640:	a8000035 	stwio	zero,0(r21)
	}
	return b;
}

inline void accelerated_shift(unsigned long *buffer, unsigned short length) {
	IOWR_32DIRECT(SWAP_ACCELERATOR_0_BASE, 0, buffer);
   40644:	00800234 	movhi	r2,8
   40648:	10843404 	addi	r2,r2,4304
   4064c:	10c00035 	stwio	r3,0(r2)
	IOWR_32DIRECT(SWAP_ACCELERATOR_0_BASE, 4, length);
   40650:	00c00234 	movhi	r3,8
   40654:	80bfffcc 	andi	r2,r16,65535
   40658:	18c43504 	addi	r3,r3,4308
   4065c:	18800035 	stwio	r2,0(r3)
	IOWR_32DIRECT(SWAP_ACCELERATOR_0_BASE, 12, 1);	// Enable interrupt
   40660:	00c00234 	movhi	r3,8
   40664:	18c43704 	addi	r3,r3,4316
   40668:	1c400035 	stwio	r17,0(r3)
	IOWR_32DIRECT(SWAP_ACCELERATOR_0_BASE, 8, 1);	// Start
   4066c:	00800234 	movhi	r2,8
   40670:	10843604 	addi	r2,r2,4312
   40674:	14400035 	stwio	r17,0(r2)
   40678:	102f883a 	mov	r23,r2
		volatile int buffer[n_samples];
		TIC
		accelerated_shift(buffer, n_samples);
		// alt_icache_flush_all();
		#if CONFIG_IRQ_ACC
			while (acclerator_done == 0);
   4067c:	d0a04217 	ldw	r2,-32504(gp)
   40680:	103ffe26 	beq	r2,zero,4067c <csv_export+0x13c>
			acclerator_done = 0;
		#else
			while ((IORD_32DIRECT(SWAP_ACCELERATOR_0_BASE, 8) & 0x0002) == 0);
			TOC
		#endif
		alt_dcache_flush_all();
   40684:	e0fff715 	stw	r3,-36(fp)
		TIC
		accelerated_shift(buffer, n_samples);
		// alt_icache_flush_all();
		#if CONFIG_IRQ_ACC
			while (acclerator_done == 0);
			acclerator_done = 0;
   40688:	d0204215 	stw	zero,-32504(gp)
		#else
			while ((IORD_32DIRECT(SWAP_ACCELERATOR_0_BASE, 8) & 0x0002) == 0);
			TOC
		#endif
		alt_dcache_flush_all();
   4068c:	00411600 	call	41160 <alt_dcache_flush_all>
		IOWR_32DIRECT(SWAP_ACCELERATOR_0_BASE, 12, 2);	// Clear `Finish` flag
   40690:	e0fff717 	ldw	r3,-36(fp)
   40694:	00800084 	movi	r2,2
   40698:	18800035 	stwio	r2,0(r3)
		while (IORD_32DIRECT(SWAP_ACCELERATOR_0_BASE, 8) & 0x02 == 0x02);
   4069c:	b8800037 	ldwio	r2,0(r23)
   406a0:	1080004c 	andi	r2,r2,1
   406a4:	103ffd1e 	bne	r2,zero,4069c <csv_export+0x15c>
		IOWR_32DIRECT(SWAP_ACCELERATOR_0_BASE, 12, 1);
   406a8:	1c400035 	stwio	r17,0(r3)
		time_accelerator = perf_get_total_time(PERFORMANCE_COUNTER_0_BASE);
   406ac:	01000234 	movhi	r4,8
   406b0:	21041004 	addi	r4,r4,4160
   406b4:	00416080 	call	41608 <perf_get_total_time>
   406b8:	102f883a 	mov	r23,r2

		// C shift
		TIC
   406bc:	9c400035 	stwio	r17,0(r19)
   406c0:	b0000035 	stwio	zero,0(r22)
   406c4:	a8000035 	stwio	zero,0(r21)
		for (int i = 0; i < n_samples; i++) {
   406c8:	002b883a 	mov	r21,zero
   406cc:	ac00050e 	bge	r21,r16,406e4 <csv_export+0x1a4>
			volatile int res = shift(i);
   406d0:	a809883a 	mov	r4,r21
   406d4:	00401c40 	call	401c4 <shift>
   406d8:	e0bff315 	stw	r2,-52(fp)
		IOWR_32DIRECT(SWAP_ACCELERATOR_0_BASE, 12, 1);
		time_accelerator = perf_get_total_time(PERFORMANCE_COUNTER_0_BASE);

		// C shift
		TIC
		for (int i = 0; i < n_samples; i++) {
   406dc:	ad400044 	addi	r21,r21,1
   406e0:	003ffa06 	br	406cc <csv_export+0x18c>
			volatile int res = shift(i);
		}
		TOC
   406e4:	a0000035 	stwio	zero,0(r20)
   406e8:	98000035 	stwio	zero,0(r19)
		time_c = perf_get_total_time(PERFORMANCE_COUNTER_0_BASE);
   406ec:	01000234 	movhi	r4,8
   406f0:	21041004 	addi	r4,r4,4160
   406f4:	00416080 	call	41608 <perf_get_total_time>

		printf("%d,%d,%d,%d\n", n_samples, time_custom, time_c, time_accelerator);
   406f8:	ddc00015 	stw	r23,0(sp)
   406fc:	e1bff517 	ldw	r6,-44(fp)
   40700:	01000134 	movhi	r4,4
   40704:	100f883a 	mov	r7,r2
   40708:	800b883a 	mov	r5,r16
   4070c:	2107e804 	addi	r4,r4,8096
   40710:	00407f40 	call	407f4 <printf>
   40714:	94800104 	addi	r18,r18,4
	unsigned int time_c;
	unsigned int time_accelerator;
	int sample_batches[] = { 50000, 10000, 5000, 1000, 500, 100, 50, 10, 5, 1 };

	printf("BatchSize,Custom,CFunction,Accelerator\n");
	for (int ni = 0; ni < sizeof(sample_batches) / 4; ni++) {
   40718:	00800a04 	movi	r2,40
   4071c:	e6fff617 	ldw	sp,-40(fp)
   40720:	90bf9d1e 	bne	r18,r2,40598 <csv_export+0x58>
		TOC
		time_c = perf_get_total_time(PERFORMANCE_COUNTER_0_BASE);

		printf("%d,%d,%d,%d\n", n_samples, time_custom, time_c, time_accelerator);
	}
}
   40724:	e6fff804 	addi	sp,fp,-32
   40728:	dfc00917 	ldw	ra,36(sp)
   4072c:	df000817 	ldw	fp,32(sp)
   40730:	ddc00717 	ldw	r23,28(sp)
   40734:	dd800617 	ldw	r22,24(sp)
   40738:	dd400517 	ldw	r21,20(sp)
   4073c:	dd000417 	ldw	r20,16(sp)
   40740:	dcc00317 	ldw	r19,12(sp)
   40744:	dc800217 	ldw	r18,8(sp)
   40748:	dc400117 	ldw	r17,4(sp)
   4074c:	dc000017 	ldw	r16,0(sp)
   40750:	dec00a04 	addi	sp,sp,40
   40754:	f800283a 	ret

00040758 <main>:

int main() {
   40758:	defffe04 	addi	sp,sp,-8
	// Enable interrupt
#if CONFIG_IRQ_ACC
	alt_ic_isr_register(
   4075c:	01800134 	movhi	r6,4
   40760:	000f883a 	mov	r7,zero
   40764:	31808804 	addi	r6,r6,544
   40768:	000b883a 	mov	r5,zero
   4076c:	0009883a 	mov	r4,zero
   40770:	d8000015 	stw	zero,0(sp)

		printf("%d,%d,%d,%d\n", n_samples, time_custom, time_c, time_accelerator);
	}
}

int main() {
   40774:	dfc00115 	stw	ra,4(sp)
	// Enable interrupt
#if CONFIG_IRQ_ACC
	alt_ic_isr_register(
   40778:	00411680 	call	41168 <alt_ic_isr_register>
#endif

	// alt_printf("Accelerator status: 0x%x\n", IORD_32DIRECT(SWAP_ACCELERATOR_0_BASE, 8));

	// Run analysis
	csv_export();;
   4077c:	00405400 	call	40540 <csv_export>

	return 0;
}
   40780:	0005883a 	mov	r2,zero
   40784:	dfc00117 	ldw	ra,4(sp)
   40788:	dec00204 	addi	sp,sp,8
   4078c:	f800283a 	ret

00040790 <memcpy>:
   40790:	2005883a 	mov	r2,r4
   40794:	2007883a 	mov	r3,r4
   40798:	218d883a 	add	r6,r4,r6
   4079c:	19800526 	beq	r3,r6,407b4 <memcpy+0x24>
   407a0:	29000003 	ldbu	r4,0(r5)
   407a4:	18c00044 	addi	r3,r3,1
   407a8:	29400044 	addi	r5,r5,1
   407ac:	193fffc5 	stb	r4,-1(r3)
   407b0:	003ffa06 	br	4079c <memcpy+0xc>
   407b4:	f800283a 	ret

000407b8 <_printf_r>:
   407b8:	defffd04 	addi	sp,sp,-12
   407bc:	dfc00015 	stw	ra,0(sp)
   407c0:	d9800115 	stw	r6,4(sp)
   407c4:	d9c00215 	stw	r7,8(sp)
   407c8:	20c00217 	ldw	r3,8(r4)
   407cc:	01800134 	movhi	r6,4
   407d0:	3183a704 	addi	r6,r6,3740
   407d4:	19800115 	stw	r6,4(r3)
   407d8:	280d883a 	mov	r6,r5
   407dc:	21400217 	ldw	r5,8(r4)
   407e0:	d9c00104 	addi	r7,sp,4
   407e4:	004095c0 	call	4095c <___vfprintf_internal_r>
   407e8:	dfc00017 	ldw	ra,0(sp)
   407ec:	dec00304 	addi	sp,sp,12
   407f0:	f800283a 	ret

000407f4 <printf>:
   407f4:	defffc04 	addi	sp,sp,-16
   407f8:	dfc00015 	stw	ra,0(sp)
   407fc:	d9400115 	stw	r5,4(sp)
   40800:	d9800215 	stw	r6,8(sp)
   40804:	d9c00315 	stw	r7,12(sp)
   40808:	00800134 	movhi	r2,4
   4080c:	1088b404 	addi	r2,r2,8912
   40810:	10800017 	ldw	r2,0(r2)
   40814:	01400134 	movhi	r5,4
   40818:	2943a704 	addi	r5,r5,3740
   4081c:	10c00217 	ldw	r3,8(r2)
   40820:	d9800104 	addi	r6,sp,4
   40824:	19400115 	stw	r5,4(r3)
   40828:	200b883a 	mov	r5,r4
   4082c:	11000217 	ldw	r4,8(r2)
   40830:	0040e800 	call	40e80 <__vfprintf_internal>
   40834:	dfc00017 	ldw	ra,0(sp)
   40838:	dec00404 	addi	sp,sp,16
   4083c:	f800283a 	ret

00040840 <_puts_r>:
   40840:	defffd04 	addi	sp,sp,-12
   40844:	dc000015 	stw	r16,0(sp)
   40848:	2021883a 	mov	r16,r4
   4084c:	2809883a 	mov	r4,r5
   40850:	dfc00215 	stw	ra,8(sp)
   40854:	dc400115 	stw	r17,4(sp)
   40858:	2823883a 	mov	r17,r5
   4085c:	00408d40 	call	408d4 <strlen>
   40860:	81400217 	ldw	r5,8(r16)
   40864:	01000134 	movhi	r4,4
   40868:	2103a704 	addi	r4,r4,3740
   4086c:	29000115 	stw	r4,4(r5)
   40870:	100f883a 	mov	r7,r2
   40874:	880d883a 	mov	r6,r17
   40878:	8009883a 	mov	r4,r16
   4087c:	0040e9c0 	call	40e9c <__sfvwrite_small_dev>
   40880:	00ffffc4 	movi	r3,-1
   40884:	10c00926 	beq	r2,r3,408ac <_puts_r+0x6c>
   40888:	81400217 	ldw	r5,8(r16)
   4088c:	01800134 	movhi	r6,4
   40890:	01c00044 	movi	r7,1
   40894:	28800117 	ldw	r2,4(r5)
   40898:	3187c104 	addi	r6,r6,7940
   4089c:	8009883a 	mov	r4,r16
   408a0:	103ee83a 	callr	r2
   408a4:	10bfffe0 	cmpeqi	r2,r2,-1
   408a8:	0085c83a 	sub	r2,zero,r2
   408ac:	dfc00217 	ldw	ra,8(sp)
   408b0:	dc400117 	ldw	r17,4(sp)
   408b4:	dc000017 	ldw	r16,0(sp)
   408b8:	dec00304 	addi	sp,sp,12
   408bc:	f800283a 	ret

000408c0 <puts>:
   408c0:	00800134 	movhi	r2,4
   408c4:	1088b404 	addi	r2,r2,8912
   408c8:	200b883a 	mov	r5,r4
   408cc:	11000017 	ldw	r4,0(r2)
   408d0:	00408401 	jmpi	40840 <_puts_r>

000408d4 <strlen>:
   408d4:	2005883a 	mov	r2,r4
   408d8:	10c00007 	ldb	r3,0(r2)
   408dc:	18000226 	beq	r3,zero,408e8 <strlen+0x14>
   408e0:	10800044 	addi	r2,r2,1
   408e4:	003ffc06 	br	408d8 <strlen+0x4>
   408e8:	1105c83a 	sub	r2,r2,r4
   408ec:	f800283a 	ret

000408f0 <print_repeat>:
   408f0:	defffb04 	addi	sp,sp,-20
   408f4:	dc800315 	stw	r18,12(sp)
   408f8:	dc400215 	stw	r17,8(sp)
   408fc:	dc000115 	stw	r16,4(sp)
   40900:	dfc00415 	stw	ra,16(sp)
   40904:	2025883a 	mov	r18,r4
   40908:	2823883a 	mov	r17,r5
   4090c:	d9800005 	stb	r6,0(sp)
   40910:	3821883a 	mov	r16,r7
   40914:	04000a0e 	bge	zero,r16,40940 <print_repeat+0x50>
   40918:	88800117 	ldw	r2,4(r17)
   4091c:	01c00044 	movi	r7,1
   40920:	d80d883a 	mov	r6,sp
   40924:	880b883a 	mov	r5,r17
   40928:	9009883a 	mov	r4,r18
   4092c:	103ee83a 	callr	r2
   40930:	843fffc4 	addi	r16,r16,-1
   40934:	103ff726 	beq	r2,zero,40914 <print_repeat+0x24>
   40938:	00bfffc4 	movi	r2,-1
   4093c:	00000106 	br	40944 <print_repeat+0x54>
   40940:	0005883a 	mov	r2,zero
   40944:	dfc00417 	ldw	ra,16(sp)
   40948:	dc800317 	ldw	r18,12(sp)
   4094c:	dc400217 	ldw	r17,8(sp)
   40950:	dc000117 	ldw	r16,4(sp)
   40954:	dec00504 	addi	sp,sp,20
   40958:	f800283a 	ret

0004095c <___vfprintf_internal_r>:
   4095c:	deffe504 	addi	sp,sp,-108
   40960:	d8c00804 	addi	r3,sp,32
   40964:	df001915 	stw	fp,100(sp)
   40968:	ddc01815 	stw	r23,96(sp)
   4096c:	dd801715 	stw	r22,92(sp)
   40970:	dd401615 	stw	r21,88(sp)
   40974:	dd001515 	stw	r20,84(sp)
   40978:	dcc01415 	stw	r19,80(sp)
   4097c:	dc801315 	stw	r18,76(sp)
   40980:	dc401215 	stw	r17,72(sp)
   40984:	dc001115 	stw	r16,68(sp)
   40988:	dfc01a15 	stw	ra,104(sp)
   4098c:	2027883a 	mov	r19,r4
   40990:	2839883a 	mov	fp,r5
   40994:	382d883a 	mov	r22,r7
   40998:	d9800f15 	stw	r6,60(sp)
   4099c:	0021883a 	mov	r16,zero
   409a0:	d8000e15 	stw	zero,56(sp)
   409a4:	002f883a 	mov	r23,zero
   409a8:	002b883a 	mov	r21,zero
   409ac:	0025883a 	mov	r18,zero
   409b0:	0023883a 	mov	r17,zero
   409b4:	d8000c15 	stw	zero,48(sp)
   409b8:	d8000b15 	stw	zero,44(sp)
   409bc:	0029883a 	mov	r20,zero
   409c0:	d8c00915 	stw	r3,36(sp)
   409c4:	d8c00f17 	ldw	r3,60(sp)
   409c8:	19000003 	ldbu	r4,0(r3)
   409cc:	20803fcc 	andi	r2,r4,255
   409d0:	1080201c 	xori	r2,r2,128
   409d4:	10bfe004 	addi	r2,r2,-128
   409d8:	10011c26 	beq	r2,zero,40e4c <___vfprintf_internal_r+0x4f0>
   409dc:	00c00044 	movi	r3,1
   409e0:	a0c01426 	beq	r20,r3,40a34 <___vfprintf_internal_r+0xd8>
   409e4:	1d000216 	blt	r3,r20,409f0 <___vfprintf_internal_r+0x94>
   409e8:	a0000626 	beq	r20,zero,40a04 <___vfprintf_internal_r+0xa8>
   409ec:	00011306 	br	40e3c <___vfprintf_internal_r+0x4e0>
   409f0:	01400084 	movi	r5,2
   409f4:	a1401d26 	beq	r20,r5,40a6c <___vfprintf_internal_r+0x110>
   409f8:	014000c4 	movi	r5,3
   409fc:	a1402926 	beq	r20,r5,40aa4 <___vfprintf_internal_r+0x148>
   40a00:	00010e06 	br	40e3c <___vfprintf_internal_r+0x4e0>
   40a04:	01400944 	movi	r5,37
   40a08:	1140fb26 	beq	r2,r5,40df8 <___vfprintf_internal_r+0x49c>
   40a0c:	e0800117 	ldw	r2,4(fp)
   40a10:	d9000005 	stb	r4,0(sp)
   40a14:	01c00044 	movi	r7,1
   40a18:	d80d883a 	mov	r6,sp
   40a1c:	e00b883a 	mov	r5,fp
   40a20:	9809883a 	mov	r4,r19
   40a24:	103ee83a 	callr	r2
   40a28:	1000d61e 	bne	r2,zero,40d84 <___vfprintf_internal_r+0x428>
   40a2c:	84000044 	addi	r16,r16,1
   40a30:	00010206 	br	40e3c <___vfprintf_internal_r+0x4e0>
   40a34:	01400c04 	movi	r5,48
   40a38:	1140f826 	beq	r2,r5,40e1c <___vfprintf_internal_r+0x4c0>
   40a3c:	01400944 	movi	r5,37
   40a40:	11400a1e 	bne	r2,r5,40a6c <___vfprintf_internal_r+0x110>
   40a44:	d8800005 	stb	r2,0(sp)
   40a48:	e0800117 	ldw	r2,4(fp)
   40a4c:	a00f883a 	mov	r7,r20
   40a50:	d80d883a 	mov	r6,sp
   40a54:	e00b883a 	mov	r5,fp
   40a58:	9809883a 	mov	r4,r19
   40a5c:	103ee83a 	callr	r2
   40a60:	1000c81e 	bne	r2,zero,40d84 <___vfprintf_internal_r+0x428>
   40a64:	84000044 	addi	r16,r16,1
   40a68:	0000f306 	br	40e38 <___vfprintf_internal_r+0x4dc>
   40a6c:	217ff404 	addi	r5,r4,-48
   40a70:	29403fcc 	andi	r5,r5,255
   40a74:	00c00244 	movi	r3,9
   40a78:	19400736 	bltu	r3,r5,40a98 <___vfprintf_internal_r+0x13c>
   40a7c:	00bfffc4 	movi	r2,-1
   40a80:	88800226 	beq	r17,r2,40a8c <___vfprintf_internal_r+0x130>
   40a84:	8c4002a4 	muli	r17,r17,10
   40a88:	00000106 	br	40a90 <___vfprintf_internal_r+0x134>
   40a8c:	0023883a 	mov	r17,zero
   40a90:	2c63883a 	add	r17,r5,r17
   40a94:	0000e206 	br	40e20 <___vfprintf_internal_r+0x4c4>
   40a98:	01400b84 	movi	r5,46
   40a9c:	1140e426 	beq	r2,r5,40e30 <___vfprintf_internal_r+0x4d4>
   40aa0:	05000084 	movi	r20,2
   40aa4:	213ff404 	addi	r4,r4,-48
   40aa8:	21003fcc 	andi	r4,r4,255
   40aac:	00c00244 	movi	r3,9
   40ab0:	19000736 	bltu	r3,r4,40ad0 <___vfprintf_internal_r+0x174>
   40ab4:	00bfffc4 	movi	r2,-1
   40ab8:	90800226 	beq	r18,r2,40ac4 <___vfprintf_internal_r+0x168>
   40abc:	948002a4 	muli	r18,r18,10
   40ac0:	00000106 	br	40ac8 <___vfprintf_internal_r+0x16c>
   40ac4:	0025883a 	mov	r18,zero
   40ac8:	24a5883a 	add	r18,r4,r18
   40acc:	0000db06 	br	40e3c <___vfprintf_internal_r+0x4e0>
   40ad0:	00c01b04 	movi	r3,108
   40ad4:	10c0d426 	beq	r2,r3,40e28 <___vfprintf_internal_r+0x4cc>
   40ad8:	013fffc4 	movi	r4,-1
   40adc:	91000226 	beq	r18,r4,40ae8 <___vfprintf_internal_r+0x18c>
   40ae0:	d8000b15 	stw	zero,44(sp)
   40ae4:	00000106 	br	40aec <___vfprintf_internal_r+0x190>
   40ae8:	04800044 	movi	r18,1
   40aec:	01001a44 	movi	r4,105
   40af0:	11001626 	beq	r2,r4,40b4c <___vfprintf_internal_r+0x1f0>
   40af4:	20800916 	blt	r4,r2,40b1c <___vfprintf_internal_r+0x1c0>
   40af8:	010018c4 	movi	r4,99
   40afc:	11008a26 	beq	r2,r4,40d28 <___vfprintf_internal_r+0x3cc>
   40b00:	01001904 	movi	r4,100
   40b04:	11001126 	beq	r2,r4,40b4c <___vfprintf_internal_r+0x1f0>
   40b08:	01001604 	movi	r4,88
   40b0c:	1100ca1e 	bne	r2,r4,40e38 <___vfprintf_internal_r+0x4dc>
   40b10:	00c00044 	movi	r3,1
   40b14:	d8c00e15 	stw	r3,56(sp)
   40b18:	00001406 	br	40b6c <___vfprintf_internal_r+0x210>
   40b1c:	01001cc4 	movi	r4,115
   40b20:	11009a26 	beq	r2,r4,40d8c <___vfprintf_internal_r+0x430>
   40b24:	20800416 	blt	r4,r2,40b38 <___vfprintf_internal_r+0x1dc>
   40b28:	01001bc4 	movi	r4,111
   40b2c:	1100c21e 	bne	r2,r4,40e38 <___vfprintf_internal_r+0x4dc>
   40b30:	05400204 	movi	r21,8
   40b34:	00000e06 	br	40b70 <___vfprintf_internal_r+0x214>
   40b38:	01001d44 	movi	r4,117
   40b3c:	11000c26 	beq	r2,r4,40b70 <___vfprintf_internal_r+0x214>
   40b40:	01001e04 	movi	r4,120
   40b44:	11000926 	beq	r2,r4,40b6c <___vfprintf_internal_r+0x210>
   40b48:	0000bb06 	br	40e38 <___vfprintf_internal_r+0x4dc>
   40b4c:	b5000104 	addi	r20,r22,4
   40b50:	b8000726 	beq	r23,zero,40b70 <___vfprintf_internal_r+0x214>
   40b54:	dd000d15 	stw	r20,52(sp)
   40b58:	b5800017 	ldw	r22,0(r22)
   40b5c:	b000080e 	bge	r22,zero,40b80 <___vfprintf_internal_r+0x224>
   40b60:	05adc83a 	sub	r22,zero,r22
   40b64:	02800044 	movi	r10,1
   40b68:	00000606 	br	40b84 <___vfprintf_internal_r+0x228>
   40b6c:	05400404 	movi	r21,16
   40b70:	b0c00104 	addi	r3,r22,4
   40b74:	d8c00d15 	stw	r3,52(sp)
   40b78:	b5800017 	ldw	r22,0(r22)
   40b7c:	002f883a 	mov	r23,zero
   40b80:	0015883a 	mov	r10,zero
   40b84:	d829883a 	mov	r20,sp
   40b88:	b0001426 	beq	r22,zero,40bdc <___vfprintf_internal_r+0x280>
   40b8c:	b009883a 	mov	r4,r22
   40b90:	a80b883a 	mov	r5,r21
   40b94:	da801015 	stw	r10,64(sp)
   40b98:	00410a40 	call	410a4 <__udivsi3>
   40b9c:	1549383a 	mul	r4,r2,r21
   40ba0:	00c00244 	movi	r3,9
   40ba4:	da801017 	ldw	r10,64(sp)
   40ba8:	b12dc83a 	sub	r22,r22,r4
   40bac:	1d800216 	blt	r3,r22,40bb8 <___vfprintf_internal_r+0x25c>
   40bb0:	b5800c04 	addi	r22,r22,48
   40bb4:	00000506 	br	40bcc <___vfprintf_internal_r+0x270>
   40bb8:	d8c00e17 	ldw	r3,56(sp)
   40bbc:	18000226 	beq	r3,zero,40bc8 <___vfprintf_internal_r+0x26c>
   40bc0:	b5800dc4 	addi	r22,r22,55
   40bc4:	00000106 	br	40bcc <___vfprintf_internal_r+0x270>
   40bc8:	b58015c4 	addi	r22,r22,87
   40bcc:	a5800005 	stb	r22,0(r20)
   40bd0:	a5000044 	addi	r20,r20,1
   40bd4:	102d883a 	mov	r22,r2
   40bd8:	003feb06 	br	40b88 <___vfprintf_internal_r+0x22c>
   40bdc:	a6c7c83a 	sub	r3,r20,sp
   40be0:	d8c00a15 	stw	r3,40(sp)
   40be4:	90c5c83a 	sub	r2,r18,r3
   40be8:	00800a0e 	bge	zero,r2,40c14 <___vfprintf_internal_r+0x2b8>
   40bec:	a085883a 	add	r2,r20,r2
   40bf0:	01400c04 	movi	r5,48
   40bf4:	d8c00917 	ldw	r3,36(sp)
   40bf8:	a009883a 	mov	r4,r20
   40bfc:	a0c0032e 	bgeu	r20,r3,40c0c <___vfprintf_internal_r+0x2b0>
   40c00:	a5000044 	addi	r20,r20,1
   40c04:	21400005 	stb	r5,0(r4)
   40c08:	a0bffa1e 	bne	r20,r2,40bf4 <___vfprintf_internal_r+0x298>
   40c0c:	a6c7c83a 	sub	r3,r20,sp
   40c10:	d8c00a15 	stw	r3,40(sp)
   40c14:	d8c00a17 	ldw	r3,40(sp)
   40c18:	50d3883a 	add	r9,r10,r3
   40c1c:	d8c00b17 	ldw	r3,44(sp)
   40c20:	8a6dc83a 	sub	r22,r17,r9
   40c24:	18001726 	beq	r3,zero,40c84 <___vfprintf_internal_r+0x328>
   40c28:	50000a26 	beq	r10,zero,40c54 <___vfprintf_internal_r+0x2f8>
   40c2c:	00800b44 	movi	r2,45
   40c30:	d8800805 	stb	r2,32(sp)
   40c34:	e0800117 	ldw	r2,4(fp)
   40c38:	01c00044 	movi	r7,1
   40c3c:	d9800804 	addi	r6,sp,32
   40c40:	e00b883a 	mov	r5,fp
   40c44:	9809883a 	mov	r4,r19
   40c48:	103ee83a 	callr	r2
   40c4c:	10004d1e 	bne	r2,zero,40d84 <___vfprintf_internal_r+0x428>
   40c50:	84000044 	addi	r16,r16,1
   40c54:	0580070e 	bge	zero,r22,40c74 <___vfprintf_internal_r+0x318>
   40c58:	b00f883a 	mov	r7,r22
   40c5c:	01800c04 	movi	r6,48
   40c60:	e00b883a 	mov	r5,fp
   40c64:	9809883a 	mov	r4,r19
   40c68:	00408f00 	call	408f0 <print_repeat>
   40c6c:	1000451e 	bne	r2,zero,40d84 <___vfprintf_internal_r+0x428>
   40c70:	85a1883a 	add	r16,r16,r22
   40c74:	d8c00a17 	ldw	r3,40(sp)
   40c78:	a013883a 	mov	r9,r20
   40c7c:	1d2dc83a 	sub	r22,r3,r20
   40c80:	00002206 	br	40d0c <___vfprintf_internal_r+0x3b0>
   40c84:	0580090e 	bge	zero,r22,40cac <___vfprintf_internal_r+0x350>
   40c88:	b00f883a 	mov	r7,r22
   40c8c:	01800804 	movi	r6,32
   40c90:	e00b883a 	mov	r5,fp
   40c94:	9809883a 	mov	r4,r19
   40c98:	da801015 	stw	r10,64(sp)
   40c9c:	00408f00 	call	408f0 <print_repeat>
   40ca0:	da801017 	ldw	r10,64(sp)
   40ca4:	1000371e 	bne	r2,zero,40d84 <___vfprintf_internal_r+0x428>
   40ca8:	85a1883a 	add	r16,r16,r22
   40cac:	503ff126 	beq	r10,zero,40c74 <___vfprintf_internal_r+0x318>
   40cb0:	00800b44 	movi	r2,45
   40cb4:	d8800805 	stb	r2,32(sp)
   40cb8:	e0800117 	ldw	r2,4(fp)
   40cbc:	01c00044 	movi	r7,1
   40cc0:	d9800804 	addi	r6,sp,32
   40cc4:	e00b883a 	mov	r5,fp
   40cc8:	9809883a 	mov	r4,r19
   40ccc:	103ee83a 	callr	r2
   40cd0:	10002c1e 	bne	r2,zero,40d84 <___vfprintf_internal_r+0x428>
   40cd4:	84000044 	addi	r16,r16,1
   40cd8:	003fe606 	br	40c74 <___vfprintf_internal_r+0x318>
   40cdc:	4a7fffc4 	addi	r9,r9,-1
   40ce0:	48800003 	ldbu	r2,0(r9)
   40ce4:	01c00044 	movi	r7,1
   40ce8:	d9800804 	addi	r6,sp,32
   40cec:	d8800805 	stb	r2,32(sp)
   40cf0:	e0800117 	ldw	r2,4(fp)
   40cf4:	e00b883a 	mov	r5,fp
   40cf8:	da401015 	stw	r9,64(sp)
   40cfc:	9809883a 	mov	r4,r19
   40d00:	103ee83a 	callr	r2
   40d04:	da401017 	ldw	r9,64(sp)
   40d08:	10001e1e 	bne	r2,zero,40d84 <___vfprintf_internal_r+0x428>
   40d0c:	8245c83a 	sub	r2,r16,r9
   40d10:	4d89883a 	add	r4,r9,r22
   40d14:	a085883a 	add	r2,r20,r2
   40d18:	013ff016 	blt	zero,r4,40cdc <___vfprintf_internal_r+0x380>
   40d1c:	1021883a 	mov	r16,r2
   40d20:	dd800d17 	ldw	r22,52(sp)
   40d24:	00004406 	br	40e38 <___vfprintf_internal_r+0x4dc>
   40d28:	00800044 	movi	r2,1
   40d2c:	1440080e 	bge	r2,r17,40d50 <___vfprintf_internal_r+0x3f4>
   40d30:	8d3fffc4 	addi	r20,r17,-1
   40d34:	a00f883a 	mov	r7,r20
   40d38:	01800804 	movi	r6,32
   40d3c:	e00b883a 	mov	r5,fp
   40d40:	9809883a 	mov	r4,r19
   40d44:	00408f00 	call	408f0 <print_repeat>
   40d48:	10000e1e 	bne	r2,zero,40d84 <___vfprintf_internal_r+0x428>
   40d4c:	8521883a 	add	r16,r16,r20
   40d50:	b0800017 	ldw	r2,0(r22)
   40d54:	01c00044 	movi	r7,1
   40d58:	d80d883a 	mov	r6,sp
   40d5c:	d8800005 	stb	r2,0(sp)
   40d60:	e0800117 	ldw	r2,4(fp)
   40d64:	e00b883a 	mov	r5,fp
   40d68:	9809883a 	mov	r4,r19
   40d6c:	b5000104 	addi	r20,r22,4
   40d70:	103ee83a 	callr	r2
   40d74:	1000031e 	bne	r2,zero,40d84 <___vfprintf_internal_r+0x428>
   40d78:	84000044 	addi	r16,r16,1
   40d7c:	a02d883a 	mov	r22,r20
   40d80:	00002d06 	br	40e38 <___vfprintf_internal_r+0x4dc>
   40d84:	00bfffc4 	movi	r2,-1
   40d88:	00003106 	br	40e50 <___vfprintf_internal_r+0x4f4>
   40d8c:	b5000017 	ldw	r20,0(r22)
   40d90:	b0c00104 	addi	r3,r22,4
   40d94:	d8c00a15 	stw	r3,40(sp)
   40d98:	a009883a 	mov	r4,r20
   40d9c:	00408d40 	call	408d4 <strlen>
   40da0:	8893c83a 	sub	r9,r17,r2
   40da4:	102d883a 	mov	r22,r2
   40da8:	0240090e 	bge	zero,r9,40dd0 <___vfprintf_internal_r+0x474>
   40dac:	480f883a 	mov	r7,r9
   40db0:	01800804 	movi	r6,32
   40db4:	e00b883a 	mov	r5,fp
   40db8:	9809883a 	mov	r4,r19
   40dbc:	da401015 	stw	r9,64(sp)
   40dc0:	00408f00 	call	408f0 <print_repeat>
   40dc4:	da401017 	ldw	r9,64(sp)
   40dc8:	103fee1e 	bne	r2,zero,40d84 <___vfprintf_internal_r+0x428>
   40dcc:	8261883a 	add	r16,r16,r9
   40dd0:	e0800117 	ldw	r2,4(fp)
   40dd4:	b00f883a 	mov	r7,r22
   40dd8:	a00d883a 	mov	r6,r20
   40ddc:	e00b883a 	mov	r5,fp
   40de0:	9809883a 	mov	r4,r19
   40de4:	103ee83a 	callr	r2
   40de8:	103fe61e 	bne	r2,zero,40d84 <___vfprintf_internal_r+0x428>
   40dec:	85a1883a 	add	r16,r16,r22
   40df0:	dd800a17 	ldw	r22,40(sp)
   40df4:	00001006 	br	40e38 <___vfprintf_internal_r+0x4dc>
   40df8:	05c00044 	movi	r23,1
   40dfc:	04bfffc4 	movi	r18,-1
   40e00:	d8000e15 	stw	zero,56(sp)
   40e04:	05400284 	movi	r21,10
   40e08:	9023883a 	mov	r17,r18
   40e0c:	d8000c15 	stw	zero,48(sp)
   40e10:	d8000b15 	stw	zero,44(sp)
   40e14:	b829883a 	mov	r20,r23
   40e18:	00000806 	br	40e3c <___vfprintf_internal_r+0x4e0>
   40e1c:	dd000b15 	stw	r20,44(sp)
   40e20:	05000084 	movi	r20,2
   40e24:	00000506 	br	40e3c <___vfprintf_internal_r+0x4e0>
   40e28:	00c00044 	movi	r3,1
   40e2c:	d8c00c15 	stw	r3,48(sp)
   40e30:	050000c4 	movi	r20,3
   40e34:	00000106 	br	40e3c <___vfprintf_internal_r+0x4e0>
   40e38:	0029883a 	mov	r20,zero
   40e3c:	d8c00f17 	ldw	r3,60(sp)
   40e40:	18c00044 	addi	r3,r3,1
   40e44:	d8c00f15 	stw	r3,60(sp)
   40e48:	003ede06 	br	409c4 <___vfprintf_internal_r+0x68>
   40e4c:	8005883a 	mov	r2,r16
   40e50:	dfc01a17 	ldw	ra,104(sp)
   40e54:	df001917 	ldw	fp,100(sp)
   40e58:	ddc01817 	ldw	r23,96(sp)
   40e5c:	dd801717 	ldw	r22,92(sp)
   40e60:	dd401617 	ldw	r21,88(sp)
   40e64:	dd001517 	ldw	r20,84(sp)
   40e68:	dcc01417 	ldw	r19,80(sp)
   40e6c:	dc801317 	ldw	r18,76(sp)
   40e70:	dc401217 	ldw	r17,72(sp)
   40e74:	dc001117 	ldw	r16,68(sp)
   40e78:	dec01b04 	addi	sp,sp,108
   40e7c:	f800283a 	ret

00040e80 <__vfprintf_internal>:
   40e80:	00800134 	movhi	r2,4
   40e84:	1088b404 	addi	r2,r2,8912
   40e88:	300f883a 	mov	r7,r6
   40e8c:	280d883a 	mov	r6,r5
   40e90:	200b883a 	mov	r5,r4
   40e94:	11000017 	ldw	r4,0(r2)
   40e98:	004095c1 	jmpi	4095c <___vfprintf_internal_r>

00040e9c <__sfvwrite_small_dev>:
   40e9c:	2880000b 	ldhu	r2,0(r5)
   40ea0:	1080020c 	andi	r2,r2,8
   40ea4:	10002126 	beq	r2,zero,40f2c <__sfvwrite_small_dev+0x90>
   40ea8:	2880008f 	ldh	r2,2(r5)
   40eac:	defffa04 	addi	sp,sp,-24
   40eb0:	dc000015 	stw	r16,0(sp)
   40eb4:	dfc00515 	stw	ra,20(sp)
   40eb8:	dd000415 	stw	r20,16(sp)
   40ebc:	dcc00315 	stw	r19,12(sp)
   40ec0:	dc800215 	stw	r18,8(sp)
   40ec4:	dc400115 	stw	r17,4(sp)
   40ec8:	2821883a 	mov	r16,r5
   40ecc:	10001216 	blt	r2,zero,40f18 <__sfvwrite_small_dev+0x7c>
   40ed0:	2027883a 	mov	r19,r4
   40ed4:	3025883a 	mov	r18,r6
   40ed8:	3823883a 	mov	r17,r7
   40edc:	05010004 	movi	r20,1024
   40ee0:	04400b0e 	bge	zero,r17,40f10 <__sfvwrite_small_dev+0x74>
   40ee4:	880f883a 	mov	r7,r17
   40ee8:	a440010e 	bge	r20,r17,40ef0 <__sfvwrite_small_dev+0x54>
   40eec:	01c10004 	movi	r7,1024
   40ef0:	8140008f 	ldh	r5,2(r16)
   40ef4:	900d883a 	mov	r6,r18
   40ef8:	9809883a 	mov	r4,r19
   40efc:	0040f540 	call	40f54 <_write_r>
   40f00:	0080050e 	bge	zero,r2,40f18 <__sfvwrite_small_dev+0x7c>
   40f04:	88a3c83a 	sub	r17,r17,r2
   40f08:	90a5883a 	add	r18,r18,r2
   40f0c:	003ff406 	br	40ee0 <__sfvwrite_small_dev+0x44>
   40f10:	0005883a 	mov	r2,zero
   40f14:	00000706 	br	40f34 <__sfvwrite_small_dev+0x98>
   40f18:	8080000b 	ldhu	r2,0(r16)
   40f1c:	10801014 	ori	r2,r2,64
   40f20:	8080000d 	sth	r2,0(r16)
   40f24:	00bfffc4 	movi	r2,-1
   40f28:	00000206 	br	40f34 <__sfvwrite_small_dev+0x98>
   40f2c:	00bfffc4 	movi	r2,-1
   40f30:	f800283a 	ret
   40f34:	dfc00517 	ldw	ra,20(sp)
   40f38:	dd000417 	ldw	r20,16(sp)
   40f3c:	dcc00317 	ldw	r19,12(sp)
   40f40:	dc800217 	ldw	r18,8(sp)
   40f44:	dc400117 	ldw	r17,4(sp)
   40f48:	dc000017 	ldw	r16,0(sp)
   40f4c:	dec00604 	addi	sp,sp,24
   40f50:	f800283a 	ret

00040f54 <_write_r>:
   40f54:	defffd04 	addi	sp,sp,-12
   40f58:	dc000015 	stw	r16,0(sp)
   40f5c:	04000134 	movhi	r16,4
   40f60:	dc400115 	stw	r17,4(sp)
   40f64:	8408f604 	addi	r16,r16,9176
   40f68:	2023883a 	mov	r17,r4
   40f6c:	2809883a 	mov	r4,r5
   40f70:	300b883a 	mov	r5,r6
   40f74:	380d883a 	mov	r6,r7
   40f78:	dfc00215 	stw	ra,8(sp)
   40f7c:	80000015 	stw	zero,0(r16)
   40f80:	00415200 	call	41520 <write>
   40f84:	00ffffc4 	movi	r3,-1
   40f88:	10c0031e 	bne	r2,r3,40f98 <_write_r+0x44>
   40f8c:	80c00017 	ldw	r3,0(r16)
   40f90:	18000126 	beq	r3,zero,40f98 <_write_r+0x44>
   40f94:	88c00015 	stw	r3,0(r17)
   40f98:	dfc00217 	ldw	ra,8(sp)
   40f9c:	dc400117 	ldw	r17,4(sp)
   40fa0:	dc000017 	ldw	r16,0(sp)
   40fa4:	dec00304 	addi	sp,sp,12
   40fa8:	f800283a 	ret

00040fac <__divsi3>:
   40fac:	20001b16 	blt	r4,zero,4101c <__divsi3+0x70>
   40fb0:	000f883a 	mov	r7,zero
   40fb4:	28001616 	blt	r5,zero,41010 <__divsi3+0x64>
   40fb8:	200d883a 	mov	r6,r4
   40fbc:	29001a2e 	bgeu	r5,r4,41028 <__divsi3+0x7c>
   40fc0:	00800804 	movi	r2,32
   40fc4:	00c00044 	movi	r3,1
   40fc8:	00000106 	br	40fd0 <__divsi3+0x24>
   40fcc:	10000d26 	beq	r2,zero,41004 <__divsi3+0x58>
   40fd0:	294b883a 	add	r5,r5,r5
   40fd4:	10bfffc4 	addi	r2,r2,-1
   40fd8:	18c7883a 	add	r3,r3,r3
   40fdc:	293ffb36 	bltu	r5,r4,40fcc <__divsi3+0x20>
   40fe0:	0005883a 	mov	r2,zero
   40fe4:	18000726 	beq	r3,zero,41004 <__divsi3+0x58>
   40fe8:	0005883a 	mov	r2,zero
   40fec:	31400236 	bltu	r6,r5,40ff8 <__divsi3+0x4c>
   40ff0:	314dc83a 	sub	r6,r6,r5
   40ff4:	10c4b03a 	or	r2,r2,r3
   40ff8:	1806d07a 	srli	r3,r3,1
   40ffc:	280ad07a 	srli	r5,r5,1
   41000:	183ffa1e 	bne	r3,zero,40fec <__divsi3+0x40>
   41004:	38000126 	beq	r7,zero,4100c <__divsi3+0x60>
   41008:	0085c83a 	sub	r2,zero,r2
   4100c:	f800283a 	ret
   41010:	014bc83a 	sub	r5,zero,r5
   41014:	39c0005c 	xori	r7,r7,1
   41018:	003fe706 	br	40fb8 <__divsi3+0xc>
   4101c:	0109c83a 	sub	r4,zero,r4
   41020:	01c00044 	movi	r7,1
   41024:	003fe306 	br	40fb4 <__divsi3+0x8>
   41028:	00c00044 	movi	r3,1
   4102c:	003fee06 	br	40fe8 <__divsi3+0x3c>

00041030 <__modsi3>:
   41030:	20001716 	blt	r4,zero,41090 <__modsi3+0x60>
   41034:	000f883a 	mov	r7,zero
   41038:	2005883a 	mov	r2,r4
   4103c:	28001216 	blt	r5,zero,41088 <__modsi3+0x58>
   41040:	2900162e 	bgeu	r5,r4,4109c <__modsi3+0x6c>
   41044:	01800804 	movi	r6,32
   41048:	00c00044 	movi	r3,1
   4104c:	00000106 	br	41054 <__modsi3+0x24>
   41050:	30000a26 	beq	r6,zero,4107c <__modsi3+0x4c>
   41054:	294b883a 	add	r5,r5,r5
   41058:	31bfffc4 	addi	r6,r6,-1
   4105c:	18c7883a 	add	r3,r3,r3
   41060:	293ffb36 	bltu	r5,r4,41050 <__modsi3+0x20>
   41064:	18000526 	beq	r3,zero,4107c <__modsi3+0x4c>
   41068:	1806d07a 	srli	r3,r3,1
   4106c:	11400136 	bltu	r2,r5,41074 <__modsi3+0x44>
   41070:	1145c83a 	sub	r2,r2,r5
   41074:	280ad07a 	srli	r5,r5,1
   41078:	183ffb1e 	bne	r3,zero,41068 <__modsi3+0x38>
   4107c:	38000126 	beq	r7,zero,41084 <__modsi3+0x54>
   41080:	0085c83a 	sub	r2,zero,r2
   41084:	f800283a 	ret
   41088:	014bc83a 	sub	r5,zero,r5
   4108c:	003fec06 	br	41040 <__modsi3+0x10>
   41090:	0109c83a 	sub	r4,zero,r4
   41094:	01c00044 	movi	r7,1
   41098:	003fe706 	br	41038 <__modsi3+0x8>
   4109c:	00c00044 	movi	r3,1
   410a0:	003ff106 	br	41068 <__modsi3+0x38>

000410a4 <__udivsi3>:
   410a4:	200d883a 	mov	r6,r4
   410a8:	2900152e 	bgeu	r5,r4,41100 <__udivsi3+0x5c>
   410ac:	28001416 	blt	r5,zero,41100 <__udivsi3+0x5c>
   410b0:	00800804 	movi	r2,32
   410b4:	00c00044 	movi	r3,1
   410b8:	00000206 	br	410c4 <__udivsi3+0x20>
   410bc:	10000e26 	beq	r2,zero,410f8 <__udivsi3+0x54>
   410c0:	28000516 	blt	r5,zero,410d8 <__udivsi3+0x34>
   410c4:	294b883a 	add	r5,r5,r5
   410c8:	10bfffc4 	addi	r2,r2,-1
   410cc:	18c7883a 	add	r3,r3,r3
   410d0:	293ffa36 	bltu	r5,r4,410bc <__udivsi3+0x18>
   410d4:	18000826 	beq	r3,zero,410f8 <__udivsi3+0x54>
   410d8:	0005883a 	mov	r2,zero
   410dc:	31400236 	bltu	r6,r5,410e8 <__udivsi3+0x44>
   410e0:	314dc83a 	sub	r6,r6,r5
   410e4:	10c4b03a 	or	r2,r2,r3
   410e8:	1806d07a 	srli	r3,r3,1
   410ec:	280ad07a 	srli	r5,r5,1
   410f0:	183ffa1e 	bne	r3,zero,410dc <__udivsi3+0x38>
   410f4:	f800283a 	ret
   410f8:	0005883a 	mov	r2,zero
   410fc:	f800283a 	ret
   41100:	00c00044 	movi	r3,1
   41104:	003ff406 	br	410d8 <__udivsi3+0x34>

00041108 <__umodsi3>:
   41108:	2005883a 	mov	r2,r4
   4110c:	2900122e 	bgeu	r5,r4,41158 <__umodsi3+0x50>
   41110:	28001116 	blt	r5,zero,41158 <__umodsi3+0x50>
   41114:	01800804 	movi	r6,32
   41118:	00c00044 	movi	r3,1
   4111c:	00000206 	br	41128 <__umodsi3+0x20>
   41120:	30000c26 	beq	r6,zero,41154 <__umodsi3+0x4c>
   41124:	28000516 	blt	r5,zero,4113c <__umodsi3+0x34>
   41128:	294b883a 	add	r5,r5,r5
   4112c:	31bfffc4 	addi	r6,r6,-1
   41130:	18c7883a 	add	r3,r3,r3
   41134:	293ffa36 	bltu	r5,r4,41120 <__umodsi3+0x18>
   41138:	18000626 	beq	r3,zero,41154 <__umodsi3+0x4c>
   4113c:	1806d07a 	srli	r3,r3,1
   41140:	11400136 	bltu	r2,r5,41148 <__umodsi3+0x40>
   41144:	1145c83a 	sub	r2,r2,r5
   41148:	280ad07a 	srli	r5,r5,1
   4114c:	183ffb1e 	bne	r3,zero,4113c <__umodsi3+0x34>
   41150:	f800283a 	ret
   41154:	f800283a 	ret
   41158:	00c00044 	movi	r3,1
   4115c:	003ff706 	br	4113c <__umodsi3+0x34>

00041160 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
   41160:	f800283a 	ret

00041164 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
   41164:	f800283a 	ret

00041168 <alt_ic_isr_register>:
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
   41168:	00411f41 	jmpi	411f4 <alt_iic_isr_register>

0004116c <alt_ic_irq_enable>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   4116c:	0009303a 	rdctl	r4,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   41170:	00bfff84 	movi	r2,-2
   41174:	2084703a 	and	r2,r4,r2
   41178:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active |= (1 << id);
   4117c:	00c00044 	movi	r3,1
   41180:	d0a04417 	ldw	r2,-32496(gp)
   41184:	194a983a 	sll	r5,r3,r5
   41188:	288ab03a 	or	r5,r5,r2
   4118c:	d1604415 	stw	r5,-32496(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
   41190:	d0a04417 	ldw	r2,-32496(gp)
   41194:	100170fa 	wrctl	ienable,r2
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   41198:	2001703a 	wrctl	status,r4
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_enable(irq);
}
   4119c:	0005883a 	mov	r2,zero
   411a0:	f800283a 	ret

000411a4 <alt_ic_irq_disable>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   411a4:	0009303a 	rdctl	r4,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   411a8:	00bfff84 	movi	r2,-2
   411ac:	2084703a 	and	r2,r4,r2
   411b0:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active &= ~(1 << id);
   411b4:	00ffff84 	movi	r3,-2
   411b8:	d0a04417 	ldw	r2,-32496(gp)
   411bc:	194a183a 	rol	r5,r3,r5
   411c0:	288a703a 	and	r5,r5,r2
   411c4:	d1604415 	stw	r5,-32496(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
   411c8:	d0a04417 	ldw	r2,-32496(gp)
   411cc:	100170fa 	wrctl	ienable,r2
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   411d0:	2001703a 	wrctl	status,r4
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_disable(irq);
}
   411d4:	0005883a 	mov	r2,zero
   411d8:	f800283a 	ret

000411dc <alt_ic_irq_enabled>:
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
   411dc:	000730fa 	rdctl	r3,ienable

    return (irq_enabled & (1 << irq)) ? 1: 0;
   411e0:	00800044 	movi	r2,1
   411e4:	1144983a 	sll	r2,r2,r5
   411e8:	10c4703a 	and	r2,r2,r3
}
   411ec:	1004c03a 	cmpne	r2,r2,zero
   411f0:	f800283a 	ret

000411f4 <alt_iic_isr_register>:
{
  int rc = -EINVAL;  
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
  alt_irq_context status;

  if (id < ALT_NIRQ)
   411f4:	00c007c4 	movi	r3,31
   411f8:	19401616 	blt	r3,r5,41254 <alt_iic_isr_register+0x60>
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
   411fc:	defffe04 	addi	sp,sp,-8
   41200:	dfc00115 	stw	ra,4(sp)
   41204:	dc000015 	stw	r16,0(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   41208:	0021303a 	rdctl	r16,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   4120c:	00ffff84 	movi	r3,-2
   41210:	80c6703a 	and	r3,r16,r3
   41214:	1801703a 	wrctl	status,r3
     * state.
     */

    status = alt_irq_disable_all();

    alt_irq[id].handler = isr;
   41218:	280490fa 	slli	r2,r5,3
   4121c:	00c00134 	movhi	r3,4
   41220:	18c8fc04 	addi	r3,r3,9200
   41224:	1885883a 	add	r2,r3,r2
   41228:	11800015 	stw	r6,0(r2)
    alt_irq[id].context = isr_context;
   4122c:	11c00115 	stw	r7,4(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
   41230:	30000226 	beq	r6,zero,4123c <alt_iic_isr_register+0x48>
   41234:	004116c0 	call	4116c <alt_ic_irq_enable>
   41238:	00000106 	br	41240 <alt_iic_isr_register+0x4c>
   4123c:	00411a40 	call	411a4 <alt_ic_irq_disable>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   41240:	8001703a 	wrctl	status,r16

    alt_irq_enable_all(status);
  }

  return rc; 
}
   41244:	dfc00117 	ldw	ra,4(sp)
   41248:	dc000017 	ldw	r16,0(sp)
   4124c:	dec00204 	addi	sp,sp,8
   41250:	f800283a 	ret
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  int rc = -EINVAL;  
   41254:	00bffa84 	movi	r2,-22
   41258:	f800283a 	ret

0004125c <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
   4125c:	deffff04 	addi	sp,sp,-4
   41260:	01000134 	movhi	r4,4
   41264:	01400134 	movhi	r5,4
   41268:	dfc00015 	stw	ra,0(sp)
   4126c:	21087b04 	addi	r4,r4,8684
   41270:	2948b804 	addi	r5,r5,8928

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
   41274:	2140061e 	bne	r4,r5,41290 <alt_load+0x34>
   41278:	01000134 	movhi	r4,4
   4127c:	01400134 	movhi	r5,4
   41280:	21000804 	addi	r4,r4,32
   41284:	29400804 	addi	r5,r5,32
   41288:	2140121e 	bne	r4,r5,412d4 <alt_load+0x78>
   4128c:	00000b06 	br	412bc <alt_load+0x60>
   41290:	00c00134 	movhi	r3,4
   41294:	18c8b804 	addi	r3,r3,8928
   41298:	1907c83a 	sub	r3,r3,r4
   4129c:	0005883a 	mov	r2,zero
  {
    while( to != end )
   412a0:	10fff526 	beq	r2,r3,41278 <alt_load+0x1c>
    {
      *to++ = *from++;
   412a4:	114f883a 	add	r7,r2,r5
   412a8:	39c00017 	ldw	r7,0(r7)
   412ac:	110d883a 	add	r6,r2,r4
   412b0:	10800104 	addi	r2,r2,4
   412b4:	31c00015 	stw	r7,0(r6)
   412b8:	003ff906 	br	412a0 <alt_load+0x44>
   412bc:	01000134 	movhi	r4,4
   412c0:	01400134 	movhi	r5,4
   412c4:	2107a804 	addi	r4,r4,7840
   412c8:	2947a804 	addi	r5,r5,7840

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
   412cc:	2140101e 	bne	r4,r5,41310 <alt_load+0xb4>
   412d0:	00000b06 	br	41300 <alt_load+0xa4>
   412d4:	00c00134 	movhi	r3,4
   412d8:	18c06204 	addi	r3,r3,392
   412dc:	1907c83a 	sub	r3,r3,r4
   412e0:	0005883a 	mov	r2,zero
  {
    while( to != end )
   412e4:	10fff526 	beq	r2,r3,412bc <alt_load+0x60>
    {
      *to++ = *from++;
   412e8:	114f883a 	add	r7,r2,r5
   412ec:	39c00017 	ldw	r7,0(r7)
   412f0:	110d883a 	add	r6,r2,r4
   412f4:	10800104 	addi	r2,r2,4
   412f8:	31c00015 	stw	r7,0(r6)
   412fc:	003ff906 	br	412e4 <alt_load+0x88>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
   41300:	00411600 	call	41160 <alt_dcache_flush_all>
  alt_icache_flush_all();
}
   41304:	dfc00017 	ldw	ra,0(sp)
   41308:	dec00104 	addi	sp,sp,4
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  alt_icache_flush_all();
   4130c:	00411641 	jmpi	41164 <alt_icache_flush_all>
   41310:	00c00134 	movhi	r3,4
   41314:	18c87b04 	addi	r3,r3,8684
   41318:	1907c83a 	sub	r3,r3,r4

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
   4131c:	0005883a 	mov	r2,zero
  {
    while( to != end )
   41320:	18bff726 	beq	r3,r2,41300 <alt_load+0xa4>
    {
      *to++ = *from++;
   41324:	114f883a 	add	r7,r2,r5
   41328:	39c00017 	ldw	r7,0(r7)
   4132c:	110d883a 	add	r6,r2,r4
   41330:	10800104 	addi	r2,r2,4
   41334:	31c00015 	stw	r7,0(r6)
   41338:	003ff906 	br	41320 <alt_load+0xc4>

0004133c <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
   4133c:	deffff04 	addi	sp,sp,-4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
   41340:	0009883a 	mov	r4,zero
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
   41344:	dfc00015 	stw	ra,0(sp)
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
   41348:	00415800 	call	41580 <alt_irq_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
   4134c:	00415a00 	call	415a0 <alt_sys_init>
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
   41350:	d1a04517 	ldw	r6,-32492(gp)
   41354:	d1604617 	ldw	r5,-32488(gp)
   41358:	d1204717 	ldw	r4,-32484(gp)
  close(STDOUT_FILENO);
  exit (result);
#endif

  ALT_LOG_PRINT_BOOT("[alt_main.c] After main - we should not be here?.\r\n");
}
   4135c:	dfc00017 	ldw	ra,0(sp)
   41360:	dec00104 	addi	sp,sp,4
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
   41364:	00407581 	jmpi	40758 <main>

00041368 <alt_printf>:
/* 
 * ALT printf function 
 */
void 
alt_printf(const char* fmt, ... )
{
   41368:	defff204 	addi	sp,sp,-56
   4136c:	2005883a 	mov	r2,r4
   41370:	dfc00a15 	stw	ra,40(sp)
   41374:	df000915 	stw	fp,36(sp)
   41378:	ddc00815 	stw	r23,32(sp)
   4137c:	dd800715 	stw	r22,28(sp)
   41380:	dd400615 	stw	r21,24(sp)
   41384:	dd000515 	stw	r20,20(sp)
   41388:	dcc00415 	stw	r19,16(sp)
   4138c:	dc800315 	stw	r18,12(sp)
   41390:	dc400215 	stw	r17,8(sp)
   41394:	dc000115 	stw	r16,4(sp)
   41398:	d9400b15 	stw	r5,44(sp)
   4139c:	d9800c15 	stw	r6,48(sp)
   413a0:	d9c00d15 	stw	r7,52(sp)
    w = fmt;
    while ((c = *w++) != 0)
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
   413a4:	04000944 	movi	r16,37
 */
void 
alt_printf(const char* fmt, ... )
{
	va_list args;
	va_start(args, fmt);
   413a8:	dd400b04 	addi	r21,sp,44
                if (c == '%')
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
                } 
                else if (c == 'c')
   413ac:	048018c4 	movi	r18,99
                {
                    int v = va_arg(args, int);
                    alt_putchar(v);
                }
                else if (c == 'x')
   413b0:	04c01e04 	movi	r19,120
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
   413b4:	05001cc4 	movi	r20,115
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
   413b8:	11000007 	ldb	r4,0(r2)
   413bc:	20003a26 	beq	r4,zero,414a8 <alt_printf+0x140>
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
   413c0:	24000226 	beq	r4,r16,413cc <alt_printf+0x64>
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
   413c4:	14400044 	addi	r17,r2,1
   413c8:	00001406 	br	4141c <alt_printf+0xb4>
        }
        else
        {
            /* Get format character.  If none     */
            /* available, processing is complete. */
            if ((c = *w++) != 0)
   413cc:	14400084 	addi	r17,r2,2
   413d0:	10800047 	ldb	r2,1(r2)
   413d4:	10003426 	beq	r2,zero,414a8 <alt_printf+0x140>
            {
                if (c == '%')
   413d8:	1400021e 	bne	r2,r16,413e4 <alt_printf+0x7c>
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
   413dc:	8009883a 	mov	r4,r16
   413e0:	00000e06 	br	4141c <alt_printf+0xb4>
                } 
                else if (c == 'c')
   413e4:	1480051e 	bne	r2,r18,413fc <alt_printf+0x94>
                {
                    int v = va_arg(args, int);
                    alt_putchar(v);
   413e8:	a9000017 	ldw	r4,0(r21)
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
                } 
                else if (c == 'c')
                {
                    int v = va_arg(args, int);
   413ec:	ad800104 	addi	r22,r21,4
   413f0:	b02b883a 	mov	r21,r22
                    alt_putchar(v);
   413f4:	00414d80 	call	414d8 <alt_putchar>
   413f8:	00002906 	br	414a0 <alt_printf+0x138>
                }
                else if (c == 'x')
   413fc:	14c0201e 	bne	r2,r19,41480 <alt_printf+0x118>
                {
                    /* Process hexadecimal number format. */
                    unsigned long v = va_arg(args, unsigned long);
   41400:	adc00017 	ldw	r23,0(r21)
   41404:	ad400104 	addi	r21,r21,4
                    unsigned long digit;
                    int digit_shift;

                    /* If the number value is zero, just print and continue. */
                    if (v == 0)
   41408:	b8000326 	beq	r23,zero,41418 <alt_printf+0xb0>
   4140c:	05800704 	movi	r22,28
                        continue;
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
   41410:	00c003c4 	movi	r3,15
   41414:	00000306 	br	41424 <alt_printf+0xbc>
                    int digit_shift;

                    /* If the number value is zero, just print and continue. */
                    if (v == 0)
                    {
                        alt_putchar('0');
   41418:	01000c04 	movi	r4,48
   4141c:	00414d80 	call	414d8 <alt_putchar>
                        continue;
   41420:	00001f06 	br	414a0 <alt_printf+0x138>
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
   41424:	1d84983a 	sll	r2,r3,r22
   41428:	15c4703a 	and	r2,r2,r23
   4142c:	1000021e 	bne	r2,zero,41438 <alt_printf+0xd0>
                        digit_shift -= 4;
   41430:	b5bfff04 	addi	r22,r22,-4
   41434:	003ffb06 	br	41424 <alt_printf+0xbc>

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
   41438:	070003c4 	movi	fp,15
                        if (digit <= 9)
   4143c:	00c00244 	movi	r3,9
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
   41440:	b0001716 	blt	r22,zero,414a0 <alt_printf+0x138>
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
   41444:	e588983a 	sll	r4,fp,r22
   41448:	25c8703a 	and	r4,r4,r23
   4144c:	2588d83a 	srl	r4,r4,r22
                        if (digit <= 9)
   41450:	19000236 	bltu	r3,r4,4145c <alt_printf+0xf4>
                            c = '0' + digit;
   41454:	21000c04 	addi	r4,r4,48
   41458:	00000106 	br	41460 <alt_printf+0xf8>
                        else
                            c = 'a' + digit - 10;
   4145c:	210015c4 	addi	r4,r4,87
                        alt_putchar(c);
   41460:	21003fcc 	andi	r4,r4,255
   41464:	2100201c 	xori	r4,r4,128
   41468:	213fe004 	addi	r4,r4,-128
   4146c:	d8c00015 	stw	r3,0(sp)
   41470:	00414d80 	call	414d8 <alt_putchar>
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
   41474:	b5bfff04 	addi	r22,r22,-4
   41478:	d8c00017 	ldw	r3,0(sp)
   4147c:	003ff006 	br	41440 <alt_printf+0xd8>
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
   41480:	1500071e 	bne	r2,r20,414a0 <alt_printf+0x138>
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);
   41484:	ad800017 	ldw	r22,0(r21)
   41488:	ad400104 	addi	r21,r21,4

                    while(*s)
   4148c:	b1000007 	ldb	r4,0(r22)
   41490:	20000326 	beq	r4,zero,414a0 <alt_printf+0x138>
                      alt_putchar(*s++);
   41494:	b5800044 	addi	r22,r22,1
   41498:	00414d80 	call	414d8 <alt_putchar>
   4149c:	003ffb06 	br	4148c <alt_printf+0x124>
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
                } 
                else if (c == 'c')
                {
                    int v = va_arg(args, int);
   414a0:	8805883a 	mov	r2,r17
   414a4:	003fc406 	br	413b8 <alt_printf+0x50>
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
   414a8:	dfc00a17 	ldw	ra,40(sp)
   414ac:	df000917 	ldw	fp,36(sp)
   414b0:	ddc00817 	ldw	r23,32(sp)
   414b4:	dd800717 	ldw	r22,28(sp)
   414b8:	dd400617 	ldw	r21,24(sp)
   414bc:	dd000517 	ldw	r20,20(sp)
   414c0:	dcc00417 	ldw	r19,16(sp)
   414c4:	dc800317 	ldw	r18,12(sp)
   414c8:	dc400217 	ldw	r17,8(sp)
   414cc:	dc000117 	ldw	r16,4(sp)
   414d0:	dec00e04 	addi	sp,sp,56
   414d4:	f800283a 	ret

000414d8 <alt_putchar>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
   414d8:	defffd04 	addi	sp,sp,-12
   414dc:	dc000115 	stw	r16,4(sp)
	char        c1 = (char)(c & 0xff);
    return write(STDOUT_FILENO,&c1,1);
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    char        c1 = (char)(c & 0xff);
   414e0:	d9000005 	stb	r4,0(sp)
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
   414e4:	2021883a 	mov	r16,r4
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    char        c1 = (char)(c & 0xff);

    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
   414e8:	01000134 	movhi	r4,4
   414ec:	000f883a 	mov	r7,zero
   414f0:	01800044 	movi	r6,1
   414f4:	d80b883a 	mov	r5,sp
   414f8:	2108b604 	addi	r4,r4,8920
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
   414fc:	dfc00215 	stw	ra,8(sp)
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    char        c1 = (char)(c & 0xff);

    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
   41500:	00415b40 	call	415b4 <altera_avalon_jtag_uart_write>
   41504:	00ffffc4 	movi	r3,-1
   41508:	10c00126 	beq	r2,r3,41510 <alt_putchar+0x38>
        return -1;
    }
    return c;
   4150c:	8005883a 	mov	r2,r16
#else
    return putchar(c);
#endif
#endif
}
   41510:	dfc00217 	ldw	ra,8(sp)
   41514:	dc000117 	ldw	r16,4(sp)
   41518:	dec00304 	addi	sp,sp,12
   4151c:	f800283a 	ret

00041520 <write>:
#if !defined(ALT_STDOUT_PRESENT) && !defined(ALT_STDERR_PRESENT)
    /* Generate a link time warning, should this function ever be called. */
    ALT_STUB_WARNING(write);
#endif

    switch (file) {
   41520:	00800044 	movi	r2,1
   41524:	20800226 	beq	r4,r2,41530 <write+0x10>
   41528:	00800084 	movi	r2,2
   4152c:	2080041e 	bne	r4,r2,41540 <write+0x20>
    case 1: /* stdout file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDOUT_DEV, ptr, len, 0);
#endif /* ALT_STDOUT_PRESENT */
#ifdef ALT_STDERR_PRESENT
    case 2: /* stderr file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDERR_DEV, ptr, len, 0);
   41530:	01000134 	movhi	r4,4
   41534:	000f883a 	mov	r7,zero
   41538:	2108b604 	addi	r4,r4,8920
   4153c:	00415b41 	jmpi	415b4 <altera_avalon_jtag_uart_write>

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  return ((alt_errno) ? alt_errno() : &errno);
   41540:	d0a00417 	ldw	r2,-32752(gp)
   41544:	10000926 	beq	r2,zero,4156c <write+0x4c>
 * Provide minimal version that just writes to the stdout/stderr devices
 * when provided.
 */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
   41548:	deffff04 	addi	sp,sp,-4
   4154c:	dfc00015 	stw	ra,0(sp)
   41550:	103ee83a 	callr	r2
#ifdef ALT_STDERR_PRESENT
    case 2: /* stderr file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDERR_DEV, ptr, len, 0);
#endif /* ALT_STDERR_PRESENT */
    default:
        ALT_ERRNO = EBADFD;
   41554:	00c01444 	movi	r3,81
   41558:	10c00015 	stw	r3,0(r2)
        return -1;
    }
}
   4155c:	00bfffc4 	movi	r2,-1
   41560:	dfc00017 	ldw	ra,0(sp)
   41564:	dec00104 	addi	sp,sp,4
   41568:	f800283a 	ret
   4156c:	d0a04304 	addi	r2,gp,-32500
#ifdef ALT_STDERR_PRESENT
    case 2: /* stderr file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDERR_DEV, ptr, len, 0);
#endif /* ALT_STDERR_PRESENT */
    default:
        ALT_ERRNO = EBADFD;
   41570:	00c01444 	movi	r3,81
   41574:	10c00015 	stw	r3,0(r2)
        return -1;
    }
}
   41578:	00bfffc4 	movi	r2,-1
   4157c:	f800283a 	ret

00041580 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
   41580:	deffff04 	addi	sp,sp,-4
   41584:	dfc00015 	stw	ra,0(sp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2_GEN2_0, nios2_gen2_0);
   41588:	00418c00 	call	418c0 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
   4158c:	00800044 	movi	r2,1
   41590:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
   41594:	dfc00017 	ldw	ra,0(sp)
   41598:	dec00104 	addi	sp,sp,4
   4159c:	f800283a 	ret

000415a0 <alt_sys_init>:

void alt_sys_init( void )
{
    ALTERA_AVALON_TIMER_INIT ( TIMER_0, timer_0);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
    ALTERA_AVALON_PERFORMANCE_COUNTER_INIT ( PERFORMANCE_COUNTER_0, performance_counter_0);
   415a0:	00800234 	movhi	r2,8
   415a4:	10841004 	addi	r2,r2,4160
   415a8:	00c00044 	movi	r3,1
   415ac:	10c00035 	stwio	r3,0(r2)
   415b0:	f800283a 	ret

000415b4 <altera_avalon_jtag_uart_write>:
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
  unsigned int base = sp->base;
   415b4:	21000017 	ldw	r4,0(r4)
 * one FIFOs worth of data.  But you said you didn't want to use interrupts :-)
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
   415b8:	3005883a 	mov	r2,r6
  unsigned int base = sp->base;

  const char * end = ptr + count;
   415bc:	298d883a 	add	r6,r5,r6

  while (ptr < end)
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
   415c0:	21c00104 	addi	r7,r4,4
{
  unsigned int base = sp->base;

  const char * end = ptr + count;

  while (ptr < end)
   415c4:	2980072e 	bgeu	r5,r6,415e4 <altera_avalon_jtag_uart_write+0x30>
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
   415c8:	38c00037 	ldwio	r3,0(r7)
   415cc:	18ffffec 	andhi	r3,r3,65535
   415d0:	183ffc26 	beq	r3,zero,415c4 <altera_avalon_jtag_uart_write+0x10>
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);
   415d4:	28c00007 	ldb	r3,0(r5)
   415d8:	20c00035 	stwio	r3,0(r4)
   415dc:	29400044 	addi	r5,r5,1
   415e0:	003ff806 	br	415c4 <altera_avalon_jtag_uart_write+0x10>

  return count;
}
   415e4:	f800283a 	ret

000415e8 <perf_get_section_time>:
{
  alt_u32 lo;
  alt_u32 hi;
  alt_u64 result = 0;

  PERF_STOP_MEASURING(hw_base_address);
   415e8:	20000035 	stwio	zero,0(r4)
  lo = IORD(hw_base_address, ( which_section*4   ));
   415ec:	280a913a 	slli	r5,r5,4
   415f0:	2145883a 	add	r2,r4,r5
   415f4:	10800037 	ldwio	r2,0(r2)
  hi = IORD(hw_base_address, ((which_section*4)+1));
   415f8:	29400104 	addi	r5,r5,4
   415fc:	2149883a 	add	r4,r4,r5
   41600:	20c00037 	ldwio	r3,0(r4)

  result = ((alt_u64)(((alt_u64) hi) << ((alt_u64)32))) | 
           ((alt_u64)(((alt_u64) lo)                 ))  ;
  return result;
}
   41604:	f800283a 	ret

00041608 <perf_get_total_time>:

alt_u64 perf_get_total_time   (void* hw_base_address)
{
  return perf_get_section_time (hw_base_address, 0);
   41608:	000b883a 	mov	r5,zero
   4160c:	00415e81 	jmpi	415e8 <perf_get_section_time>

00041610 <perf_get_num_starts>:
}

alt_u32 perf_get_num_starts   (void* hw_base_address, int which_section)
{
  return IORD(hw_base_address, ((which_section*4)+2));
   41610:	280a913a 	slli	r5,r5,4
   41614:	29400204 	addi	r5,r5,8
   41618:	2149883a 	add	r4,r4,r5
}
   4161c:	20800037 	ldwio	r2,0(r4)
   41620:	f800283a 	ret

00041624 <alt_get_performance_counter_base>:
#ifdef PERFORMANCE_COUNTER_0_BASE
    return (void*)PERFORMANCE_COUNTER_0_BASE;
#else
    return (void*)0;
#endif
}
   41624:	00800234 	movhi	r2,8
   41628:	10841004 	addi	r2,r2,4160
   4162c:	f800283a 	ret

00041630 <alt_get_cpu_freq>:
 */
alt_u32 
alt_get_cpu_freq()
{
    return ALT_CPU_FREQ;
}
   41630:	0080bef4 	movhi	r2,763
   41634:	10bc2004 	addi	r2,r2,-3968
   41638:	f800283a 	ret

0004163c <perf_print_formatted_report>:
 * second.
 */
int perf_print_formatted_report (void* perf_base, 
                                 alt_u32 clock_freq_hertz,
                                 int num_sections, ...)
{
   4163c:	defff404 	addi	sp,sp,-48
   41640:	df000915 	stw	fp,36(sp)
   41644:	dd800715 	stw	r22,28(sp)
   41648:	dd000515 	stw	r20,20(sp)
   4164c:	282d883a 	mov	r22,r5
   41650:	2029883a 	mov	r20,r4
   41654:	3039883a 	mov	fp,r6
   41658:	dfc00a15 	stw	ra,40(sp)
   4165c:	ddc00815 	stw	r23,32(sp)
   41660:	dd400615 	stw	r21,24(sp)
   41664:	dcc00415 	stw	r19,16(sp)
   41668:	dc800315 	stw	r18,12(sp)
   4166c:	dc400215 	stw	r17,8(sp)
   41670:	dc000115 	stw	r16,4(sp)
   41674:	d9c00b15 	stw	r7,44(sp)
      "+---------------+-----+------------+---------------+------------+\n";
    
    const char* column_header =
      "| Section       |  %  | Time (usec)|  Time (clocks)|Occurrences |\n";

    PERF_STOP_MEASURING (perf_base);
   41678:	20000035 	stwio	zero,0(r4)

    va_start (name_args, num_sections);

    total_clocks = perf_get_total_time (perf_base);
   4167c:	00416080 	call	41608 <perf_get_total_time>
    total_usec = total_clocks * 1000000 / clock_freq_hertz;

    // Print the total at the top:
    printf("--Performance Counter Report--\n");
   41680:	01000134 	movhi	r4,4
   41684:	2107f904 	addi	r4,r4,8164

    PERF_STOP_MEASURING (perf_base);

    va_start (name_args, num_sections);

    total_clocks = perf_get_total_time (perf_base);
   41688:	1825883a 	mov	r18,r3
   4168c:	1023883a 	mov	r17,r2
    total_usec = total_clocks * 1000000 / clock_freq_hertz;

    // Print the total at the top:
    printf("--Performance Counter Report--\n");
   41690:	00408c00 	call	408c0 <puts>
    printf("Total Time : %llu usec ", total_usec);            
   41694:	018003f4 	movhi	r6,15
   41698:	31909004 	addi	r6,r6,16960
   4169c:	000f883a 	mov	r7,zero
   416a0:	8809883a 	mov	r4,r17
   416a4:	900b883a 	mov	r5,r18
   416a8:	00418c80 	call	418c8 <__muldi3>
   416ac:	000f883a 	mov	r7,zero
   416b0:	b00d883a 	mov	r6,r22
   416b4:	1009883a 	mov	r4,r2
   416b8:	180b883a 	mov	r5,r3
   416bc:	00419280 	call	41928 <__udivdi3>
   416c0:	01000134 	movhi	r4,4
   416c4:	180d883a 	mov	r6,r3
   416c8:	100b883a 	mov	r5,r2
   416cc:	21080104 	addi	r4,r4,8196
   416d0:	00407f40 	call	407f4 <printf>
    printf("(%llu clock-cycles)\n", total_clocks);            
   416d4:	01000134 	movhi	r4,4
   416d8:	900d883a 	mov	r6,r18
   416dc:	880b883a 	mov	r5,r17
   416e0:	21080704 	addi	r4,r4,8220
   416e4:	00407f40 	call	407f4 <printf>
    printf("%s", separator);
   416e8:	01000134 	movhi	r4,4
   416ec:	21080d04 	addi	r4,r4,8244
   416f0:	00408c00 	call	408c0 <puts>
    printf("%s", column_header);
   416f4:	01000134 	movhi	r4,4
   416f8:	21081e04 	addi	r4,r4,8312
   416fc:	00408c00 	call	408c0 <puts>
    printf("%s", separator);
   41700:	01000134 	movhi	r4,4
   41704:	21080d04 	addi	r4,r4,8244
   41708:	00408c00 	call	408c0 <puts>

    section_name = va_arg(name_args, char*);
   4170c:	d9800b17 	ldw	r6,44(sp)
   41710:	dcc00c04 	addi	r19,sp,48

    for (section_num = 1; section_num <= num_sections; section_num++)
   41714:	04000044 	movi	r16,1
   41718:	e4003f16 	blt	fp,r16,41818 <perf_print_formatted_report+0x1dc>
    {
        section_clocks = perf_get_section_time (perf_base, section_num);
   4171c:	800b883a 	mov	r5,r16
   41720:	a009883a 	mov	r4,r20
   41724:	d9800015 	stw	r6,0(sp)
   41728:	00415e80 	call	415e8 <perf_get_section_time>
        /* section name, small C library does not support left-justify, 
         * uses right-justify instead.
         */
        printf ("|%15s", section_name);
   4172c:	d9800017 	ldw	r6,0(sp)
   41730:	01000134 	movhi	r4,4
   41734:	21082f04 	addi	r4,r4,8380
   41738:	300b883a 	mov	r5,r6

    section_name = va_arg(name_args, char*);

    for (section_num = 1; section_num <= num_sections; section_num++)
    {
        section_clocks = perf_get_section_time (perf_base, section_num);
   4173c:	102b883a 	mov	r21,r2
   41740:	182f883a 	mov	r23,r3
        /* section name, small C library does not support left-justify, 
         * uses right-justify instead.
         */
        printf ("|%15s", section_name);
   41744:	00407f40 	call	407f4 <printf>

        /* section usage */
        if (total_clocks) 
   41748:	8c84b03a 	or	r2,r17,r18
   4174c:	10000c26 	beq	r2,zero,41780 <perf_print_formatted_report+0x144>
        {
            printf ("|%4u ", (unsigned int)(section_clocks * 100 / total_clocks));
   41750:	01801904 	movi	r6,100
   41754:	000f883a 	mov	r7,zero
   41758:	a809883a 	mov	r4,r21
   4175c:	b80b883a 	mov	r5,r23
   41760:	00418c80 	call	418c8 <__muldi3>
   41764:	180b883a 	mov	r5,r3
   41768:	880d883a 	mov	r6,r17
   4176c:	900f883a 	mov	r7,r18
   41770:	1009883a 	mov	r4,r2
   41774:	00419280 	call	41928 <__udivdi3>
   41778:	100b883a 	mov	r5,r2
   4177c:	00000106 	br	41784 <perf_print_formatted_report+0x148>
        }
        else
        {
            printf ("|%4u ", 0);
   41780:	000b883a 	mov	r5,zero
   41784:	01000134 	movhi	r4,4
   41788:	21083104 	addi	r4,r4,8388
   4178c:	00407f40 	call	407f4 <printf>
        }        

        /* section usecs */
        printf ("|%11llu ", (alt_u64)(section_clocks * 1000000 / clock_freq_hertz));
   41790:	018003f4 	movhi	r6,15
   41794:	31909004 	addi	r6,r6,16960
   41798:	000f883a 	mov	r7,zero
   4179c:	a809883a 	mov	r4,r21
   417a0:	b80b883a 	mov	r5,r23
   417a4:	00418c80 	call	418c8 <__muldi3>
   417a8:	000f883a 	mov	r7,zero
   417ac:	b00d883a 	mov	r6,r22
   417b0:	1009883a 	mov	r4,r2
   417b4:	180b883a 	mov	r5,r3
   417b8:	00419280 	call	41928 <__udivdi3>
   417bc:	01000134 	movhi	r4,4
   417c0:	180d883a 	mov	r6,r3
   417c4:	100b883a 	mov	r5,r2
   417c8:	21083304 	addi	r4,r4,8396
   417cc:	00407f40 	call	407f4 <printf>

        /* section clocks */
        printf ("|%14u ", (unsigned int)section_clocks);
   417d0:	01000134 	movhi	r4,4
   417d4:	a80b883a 	mov	r5,r21
   417d8:	21083604 	addi	r4,r4,8408
   417dc:	00407f40 	call	407f4 <printf>

        /* section occurrences */
        printf ("|%10u  |\n",
        (unsigned int) perf_get_num_starts (perf_base, section_num));
   417e0:	800b883a 	mov	r5,r16
   417e4:	a009883a 	mov	r4,r20
   417e8:	00416100 	call	41610 <perf_get_num_starts>

        /* section clocks */
        printf ("|%14u ", (unsigned int)section_clocks);

        /* section occurrences */
        printf ("|%10u  |\n",
   417ec:	01000134 	movhi	r4,4
   417f0:	100b883a 	mov	r5,r2
   417f4:	21083804 	addi	r4,r4,8416
   417f8:	00407f40 	call	407f4 <printf>
        (unsigned int) perf_get_num_starts (perf_base, section_num));

        printf ("%s", separator);
   417fc:	01000134 	movhi	r4,4
   41800:	21080d04 	addi	r4,r4,8244
   41804:	00408c00 	call	408c0 <puts>

        section_name = va_arg(name_args, char*);
   41808:	99800017 	ldw	r6,0(r19)
    printf("%s", column_header);
    printf("%s", separator);

    section_name = va_arg(name_args, char*);

    for (section_num = 1; section_num <= num_sections; section_num++)
   4180c:	84000044 	addi	r16,r16,1
        printf ("|%10u  |\n",
        (unsigned int) perf_get_num_starts (perf_base, section_num));

        printf ("%s", separator);

        section_name = va_arg(name_args, char*);
   41810:	9cc00104 	addi	r19,r19,4
   41814:	003fc006 	br	41718 <perf_print_formatted_report+0xdc>
    }

    va_end (name_args);

    return 0;
}
   41818:	0005883a 	mov	r2,zero
   4181c:	dfc00a17 	ldw	ra,40(sp)
   41820:	df000917 	ldw	fp,36(sp)
   41824:	ddc00817 	ldw	r23,32(sp)
   41828:	dd800717 	ldw	r22,28(sp)
   4182c:	dd400617 	ldw	r21,24(sp)
   41830:	dd000517 	ldw	r20,20(sp)
   41834:	dcc00417 	ldw	r19,16(sp)
   41838:	dc800317 	ldw	r18,12(sp)
   4183c:	dc400217 	ldw	r17,8(sp)
   41840:	dc000117 	ldw	r16,4(sp)
   41844:	dec00c04 	addi	sp,sp,48
   41848:	f800283a 	ret

0004184c <alt_exception_cause_generated_bad_addr>:
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
  switch (cause) {
   4184c:	213ffe84 	addi	r4,r4,-6
   41850:	008003c4 	movi	r2,15
   41854:	11001636 	bltu	r2,r4,418b0 <alt_exception_cause_generated_bad_addr+0x64>
   41858:	200890ba 	slli	r4,r4,2
   4185c:	00800134 	movhi	r2,4
   41860:	10861c04 	addi	r2,r2,6256
   41864:	2089883a 	add	r4,r4,r2
   41868:	20800017 	ldw	r2,0(r4)
   4186c:	1000683a 	jmp	r2
   41870:	000418b8 	rdprs	zero,zero,4194
   41874:	000418b8 	rdprs	zero,zero,4194
   41878:	000418b0 	cmpltui	zero,zero,4194
   4187c:	000418b0 	cmpltui	zero,zero,4194
   41880:	000418b0 	cmpltui	zero,zero,4194
   41884:	000418b8 	rdprs	zero,zero,4194
   41888:	000418b0 	cmpltui	zero,zero,4194
   4188c:	000418b0 	cmpltui	zero,zero,4194
   41890:	000418b8 	rdprs	zero,zero,4194
   41894:	000418b8 	rdprs	zero,zero,4194
   41898:	000418b0 	cmpltui	zero,zero,4194
   4189c:	000418b8 	rdprs	zero,zero,4194
   418a0:	000418b0 	cmpltui	zero,zero,4194
   418a4:	000418b0 	cmpltui	zero,zero,4194
   418a8:	000418b0 	cmpltui	zero,zero,4194
   418ac:	000418b8 	rdprs	zero,zero,4194
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
   418b0:	0005883a 	mov	r2,zero
   418b4:	f800283a 	ret
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
   418b8:	00800044 	movi	r2,1
    return 0;

  default:
    return 0;
  }
}
   418bc:	f800283a 	ret

000418c0 <altera_nios2_gen2_irq_init>:
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
    NIOS2_WRITE_IENABLE(0);
   418c0:	000170fa 	wrctl	ienable,zero
   418c4:	f800283a 	ret

000418c8 <__muldi3>:
   418c8:	223fffcc 	andi	r8,r4,65535
   418cc:	2006d43a 	srli	r3,r4,16
   418d0:	32bfffcc 	andi	r10,r6,65535
   418d4:	3012d43a 	srli	r9,r6,16
   418d8:	4297383a 	mul	r11,r8,r10
   418dc:	1a95383a 	mul	r10,r3,r10
   418e0:	4251383a 	mul	r8,r8,r9
   418e4:	5804d43a 	srli	r2,r11,16
   418e8:	4291883a 	add	r8,r8,r10
   418ec:	1205883a 	add	r2,r2,r8
   418f0:	1a51383a 	mul	r8,r3,r9
   418f4:	1280022e 	bgeu	r2,r10,41900 <__muldi3+0x38>
   418f8:	00c00074 	movhi	r3,1
   418fc:	40d1883a 	add	r8,r8,r3
   41900:	1006d43a 	srli	r3,r2,16
   41904:	21cf383a 	mul	r7,r4,r7
   41908:	314b383a 	mul	r5,r6,r5
   4190c:	1004943a 	slli	r2,r2,16
   41910:	1a11883a 	add	r8,r3,r8
   41914:	5affffcc 	andi	r11,r11,65535
   41918:	3947883a 	add	r3,r7,r5
   4191c:	12c5883a 	add	r2,r2,r11
   41920:	1a07883a 	add	r3,r3,r8
   41924:	f800283a 	ret

00041928 <__udivdi3>:
   41928:	defff504 	addi	sp,sp,-44
   4192c:	dcc00415 	stw	r19,16(sp)
   41930:	dc000115 	stw	r16,4(sp)
   41934:	dfc00a15 	stw	ra,40(sp)
   41938:	df000915 	stw	fp,36(sp)
   4193c:	ddc00815 	stw	r23,32(sp)
   41940:	dd800715 	stw	r22,28(sp)
   41944:	dd400615 	stw	r21,24(sp)
   41948:	dd000515 	stw	r20,20(sp)
   4194c:	dc800315 	stw	r18,12(sp)
   41950:	dc400215 	stw	r17,8(sp)
   41954:	2027883a 	mov	r19,r4
   41958:	2821883a 	mov	r16,r5
   4195c:	3800411e 	bne	r7,zero,41a64 <__udivdi3+0x13c>
   41960:	3023883a 	mov	r17,r6
   41964:	2025883a 	mov	r18,r4
   41968:	2980522e 	bgeu	r5,r6,41ab4 <__udivdi3+0x18c>
   4196c:	00bfffd4 	movui	r2,65535
   41970:	282d883a 	mov	r22,r5
   41974:	1180a836 	bltu	r2,r6,41c18 <__udivdi3+0x2f0>
   41978:	00803fc4 	movi	r2,255
   4197c:	1185803a 	cmpltu	r2,r2,r6
   41980:	100490fa 	slli	r2,r2,3
   41984:	3086d83a 	srl	r3,r6,r2
   41988:	01000134 	movhi	r4,4
   4198c:	21083b04 	addi	r4,r4,8428
   41990:	20c7883a 	add	r3,r4,r3
   41994:	18c00003 	ldbu	r3,0(r3)
   41998:	1885883a 	add	r2,r3,r2
   4199c:	00c00804 	movi	r3,32
   419a0:	1887c83a 	sub	r3,r3,r2
   419a4:	18000526 	beq	r3,zero,419bc <__udivdi3+0x94>
   419a8:	80e0983a 	sll	r16,r16,r3
   419ac:	9884d83a 	srl	r2,r19,r2
   419b0:	30e2983a 	sll	r17,r6,r3
   419b4:	98e4983a 	sll	r18,r19,r3
   419b8:	142cb03a 	or	r22,r2,r16
   419bc:	882ad43a 	srli	r21,r17,16
   419c0:	b009883a 	mov	r4,r22
   419c4:	8d3fffcc 	andi	r20,r17,65535
   419c8:	a80b883a 	mov	r5,r21
   419cc:	00411080 	call	41108 <__umodsi3>
   419d0:	b009883a 	mov	r4,r22
   419d4:	a80b883a 	mov	r5,r21
   419d8:	1027883a 	mov	r19,r2
   419dc:	00410a40 	call	410a4 <__udivsi3>
   419e0:	102d883a 	mov	r22,r2
   419e4:	9826943a 	slli	r19,r19,16
   419e8:	9004d43a 	srli	r2,r18,16
   419ec:	a5a1383a 	mul	r16,r20,r22
   419f0:	14c4b03a 	or	r2,r2,r19
   419f4:	1400052e 	bgeu	r2,r16,41a0c <__udivdi3+0xe4>
   419f8:	1445883a 	add	r2,r2,r17
   419fc:	b0ffffc4 	addi	r3,r22,-1
   41a00:	14400136 	bltu	r2,r17,41a08 <__udivdi3+0xe0>
   41a04:	14012336 	bltu	r2,r16,41e94 <__udivdi3+0x56c>
   41a08:	182d883a 	mov	r22,r3
   41a0c:	1421c83a 	sub	r16,r2,r16
   41a10:	a80b883a 	mov	r5,r21
   41a14:	8009883a 	mov	r4,r16
   41a18:	00411080 	call	41108 <__umodsi3>
   41a1c:	1027883a 	mov	r19,r2
   41a20:	a80b883a 	mov	r5,r21
   41a24:	8009883a 	mov	r4,r16
   41a28:	00410a40 	call	410a4 <__udivsi3>
   41a2c:	9826943a 	slli	r19,r19,16
   41a30:	a0a9383a 	mul	r20,r20,r2
   41a34:	94bfffcc 	andi	r18,r18,65535
   41a38:	94e4b03a 	or	r18,r18,r19
   41a3c:	9500052e 	bgeu	r18,r20,41a54 <__udivdi3+0x12c>
   41a40:	8ca5883a 	add	r18,r17,r18
   41a44:	10ffffc4 	addi	r3,r2,-1
   41a48:	9440f136 	bltu	r18,r17,41e10 <__udivdi3+0x4e8>
   41a4c:	9500f02e 	bgeu	r18,r20,41e10 <__udivdi3+0x4e8>
   41a50:	10bfff84 	addi	r2,r2,-2
   41a54:	b00c943a 	slli	r6,r22,16
   41a58:	0007883a 	mov	r3,zero
   41a5c:	3084b03a 	or	r2,r6,r2
   41a60:	00005906 	br	41bc8 <__udivdi3+0x2a0>
   41a64:	29c05636 	bltu	r5,r7,41bc0 <__udivdi3+0x298>
   41a68:	00bfffd4 	movui	r2,65535
   41a6c:	11c0622e 	bgeu	r2,r7,41bf8 <__udivdi3+0x2d0>
   41a70:	00804034 	movhi	r2,256
   41a74:	10bfffc4 	addi	r2,r2,-1
   41a78:	11c0ee36 	bltu	r2,r7,41e34 <__udivdi3+0x50c>
   41a7c:	00800404 	movi	r2,16
   41a80:	3886d83a 	srl	r3,r7,r2
   41a84:	01000134 	movhi	r4,4
   41a88:	21083b04 	addi	r4,r4,8428
   41a8c:	20c7883a 	add	r3,r4,r3
   41a90:	18c00003 	ldbu	r3,0(r3)
   41a94:	05400804 	movi	r21,32
   41a98:	1885883a 	add	r2,r3,r2
   41a9c:	a8abc83a 	sub	r21,r21,r2
   41aa0:	a800621e 	bne	r21,zero,41c2c <__udivdi3+0x304>
   41aa4:	3c00e936 	bltu	r7,r16,41e4c <__udivdi3+0x524>
   41aa8:	9985403a 	cmpgeu	r2,r19,r6
   41aac:	0007883a 	mov	r3,zero
   41ab0:	00004506 	br	41bc8 <__udivdi3+0x2a0>
   41ab4:	3000041e 	bne	r6,zero,41ac8 <__udivdi3+0x1a0>
   41ab8:	000b883a 	mov	r5,zero
   41abc:	01000044 	movi	r4,1
   41ac0:	00410a40 	call	410a4 <__udivsi3>
   41ac4:	1023883a 	mov	r17,r2
   41ac8:	00bfffd4 	movui	r2,65535
   41acc:	14404e2e 	bgeu	r2,r17,41c08 <__udivdi3+0x2e0>
   41ad0:	00804034 	movhi	r2,256
   41ad4:	10bfffc4 	addi	r2,r2,-1
   41ad8:	1440d836 	bltu	r2,r17,41e3c <__udivdi3+0x514>
   41adc:	00800404 	movi	r2,16
   41ae0:	8886d83a 	srl	r3,r17,r2
   41ae4:	01000134 	movhi	r4,4
   41ae8:	21083b04 	addi	r4,r4,8428
   41aec:	20c7883a 	add	r3,r4,r3
   41af0:	18c00003 	ldbu	r3,0(r3)
   41af4:	1885883a 	add	r2,r3,r2
   41af8:	00c00804 	movi	r3,32
   41afc:	1887c83a 	sub	r3,r3,r2
   41b00:	18008f1e 	bne	r3,zero,41d40 <__udivdi3+0x418>
   41b04:	882ad43a 	srli	r21,r17,16
   41b08:	8461c83a 	sub	r16,r16,r17
   41b0c:	8d3fffcc 	andi	r20,r17,65535
   41b10:	00c00044 	movi	r3,1
   41b14:	8009883a 	mov	r4,r16
   41b18:	a80b883a 	mov	r5,r21
   41b1c:	d8c00015 	stw	r3,0(sp)
   41b20:	00411080 	call	41108 <__umodsi3>
   41b24:	8009883a 	mov	r4,r16
   41b28:	a80b883a 	mov	r5,r21
   41b2c:	1027883a 	mov	r19,r2
   41b30:	00410a40 	call	410a4 <__udivsi3>
   41b34:	9826943a 	slli	r19,r19,16
   41b38:	9008d43a 	srli	r4,r18,16
   41b3c:	1521383a 	mul	r16,r2,r20
   41b40:	102d883a 	mov	r22,r2
   41b44:	24c8b03a 	or	r4,r4,r19
   41b48:	d8c00017 	ldw	r3,0(sp)
   41b4c:	2400052e 	bgeu	r4,r16,41b64 <__udivdi3+0x23c>
   41b50:	2449883a 	add	r4,r4,r17
   41b54:	b0bfffc4 	addi	r2,r22,-1
   41b58:	24400136 	bltu	r4,r17,41b60 <__udivdi3+0x238>
   41b5c:	2400ca36 	bltu	r4,r16,41e88 <__udivdi3+0x560>
   41b60:	102d883a 	mov	r22,r2
   41b64:	2421c83a 	sub	r16,r4,r16
   41b68:	a80b883a 	mov	r5,r21
   41b6c:	8009883a 	mov	r4,r16
   41b70:	d8c00015 	stw	r3,0(sp)
   41b74:	00411080 	call	41108 <__umodsi3>
   41b78:	1027883a 	mov	r19,r2
   41b7c:	a80b883a 	mov	r5,r21
   41b80:	8009883a 	mov	r4,r16
   41b84:	00410a40 	call	410a4 <__udivsi3>
   41b88:	9826943a 	slli	r19,r19,16
   41b8c:	1529383a 	mul	r20,r2,r20
   41b90:	94bfffcc 	andi	r18,r18,65535
   41b94:	94e4b03a 	or	r18,r18,r19
   41b98:	d8c00017 	ldw	r3,0(sp)
   41b9c:	9500052e 	bgeu	r18,r20,41bb4 <__udivdi3+0x28c>
   41ba0:	8ca5883a 	add	r18,r17,r18
   41ba4:	113fffc4 	addi	r4,r2,-1
   41ba8:	94409736 	bltu	r18,r17,41e08 <__udivdi3+0x4e0>
   41bac:	9500962e 	bgeu	r18,r20,41e08 <__udivdi3+0x4e0>
   41bb0:	10bfff84 	addi	r2,r2,-2
   41bb4:	b00c943a 	slli	r6,r22,16
   41bb8:	3084b03a 	or	r2,r6,r2
   41bbc:	00000206 	br	41bc8 <__udivdi3+0x2a0>
   41bc0:	0007883a 	mov	r3,zero
   41bc4:	0005883a 	mov	r2,zero
   41bc8:	dfc00a17 	ldw	ra,40(sp)
   41bcc:	df000917 	ldw	fp,36(sp)
   41bd0:	ddc00817 	ldw	r23,32(sp)
   41bd4:	dd800717 	ldw	r22,28(sp)
   41bd8:	dd400617 	ldw	r21,24(sp)
   41bdc:	dd000517 	ldw	r20,20(sp)
   41be0:	dcc00417 	ldw	r19,16(sp)
   41be4:	dc800317 	ldw	r18,12(sp)
   41be8:	dc400217 	ldw	r17,8(sp)
   41bec:	dc000117 	ldw	r16,4(sp)
   41bf0:	dec00b04 	addi	sp,sp,44
   41bf4:	f800283a 	ret
   41bf8:	00803fc4 	movi	r2,255
   41bfc:	11c5803a 	cmpltu	r2,r2,r7
   41c00:	100490fa 	slli	r2,r2,3
   41c04:	003f9e06 	br	41a80 <__udivdi3+0x158>
   41c08:	00803fc4 	movi	r2,255
   41c0c:	1445803a 	cmpltu	r2,r2,r17
   41c10:	100490fa 	slli	r2,r2,3
   41c14:	003fb206 	br	41ae0 <__udivdi3+0x1b8>
   41c18:	00804034 	movhi	r2,256
   41c1c:	10bfffc4 	addi	r2,r2,-1
   41c20:	11808836 	bltu	r2,r6,41e44 <__udivdi3+0x51c>
   41c24:	00800404 	movi	r2,16
   41c28:	003f5606 	br	41984 <__udivdi3+0x5c>
   41c2c:	30aed83a 	srl	r23,r6,r2
   41c30:	3d4e983a 	sll	r7,r7,r21
   41c34:	80acd83a 	srl	r22,r16,r2
   41c38:	9884d83a 	srl	r2,r19,r2
   41c3c:	3deeb03a 	or	r23,r7,r23
   41c40:	b824d43a 	srli	r18,r23,16
   41c44:	8560983a 	sll	r16,r16,r21
   41c48:	b009883a 	mov	r4,r22
   41c4c:	900b883a 	mov	r5,r18
   41c50:	3568983a 	sll	r20,r6,r21
   41c54:	1420b03a 	or	r16,r2,r16
   41c58:	00411080 	call	41108 <__umodsi3>
   41c5c:	b009883a 	mov	r4,r22
   41c60:	900b883a 	mov	r5,r18
   41c64:	1023883a 	mov	r17,r2
   41c68:	00410a40 	call	410a4 <__udivsi3>
   41c6c:	8808943a 	slli	r4,r17,16
   41c70:	bf3fffcc 	andi	fp,r23,65535
   41c74:	8006d43a 	srli	r3,r16,16
   41c78:	e0a3383a 	mul	r17,fp,r2
   41c7c:	100d883a 	mov	r6,r2
   41c80:	1906b03a 	or	r3,r3,r4
   41c84:	1c40042e 	bgeu	r3,r17,41c98 <__udivdi3+0x370>
   41c88:	1dc7883a 	add	r3,r3,r23
   41c8c:	10bfffc4 	addi	r2,r2,-1
   41c90:	1dc0752e 	bgeu	r3,r23,41e68 <__udivdi3+0x540>
   41c94:	100d883a 	mov	r6,r2
   41c98:	1c63c83a 	sub	r17,r3,r17
   41c9c:	900b883a 	mov	r5,r18
   41ca0:	8809883a 	mov	r4,r17
   41ca4:	d9800015 	stw	r6,0(sp)
   41ca8:	00411080 	call	41108 <__umodsi3>
   41cac:	102d883a 	mov	r22,r2
   41cb0:	8809883a 	mov	r4,r17
   41cb4:	900b883a 	mov	r5,r18
   41cb8:	00410a40 	call	410a4 <__udivsi3>
   41cbc:	b02c943a 	slli	r22,r22,16
   41cc0:	e089383a 	mul	r4,fp,r2
   41cc4:	843fffcc 	andi	r16,r16,65535
   41cc8:	85a0b03a 	or	r16,r16,r22
   41ccc:	d9800017 	ldw	r6,0(sp)
   41cd0:	8100042e 	bgeu	r16,r4,41ce4 <__udivdi3+0x3bc>
   41cd4:	85e1883a 	add	r16,r16,r23
   41cd8:	10ffffc4 	addi	r3,r2,-1
   41cdc:	85c05e2e 	bgeu	r16,r23,41e58 <__udivdi3+0x530>
   41ce0:	1805883a 	mov	r2,r3
   41ce4:	300c943a 	slli	r6,r6,16
   41ce8:	a17fffcc 	andi	r5,r20,65535
   41cec:	a028d43a 	srli	r20,r20,16
   41cf0:	3084b03a 	or	r2,r6,r2
   41cf4:	10ffffcc 	andi	r3,r2,65535
   41cf8:	100cd43a 	srli	r6,r2,16
   41cfc:	194f383a 	mul	r7,r3,r5
   41d00:	1d07383a 	mul	r3,r3,r20
   41d04:	314b383a 	mul	r5,r6,r5
   41d08:	3810d43a 	srli	r8,r7,16
   41d0c:	8121c83a 	sub	r16,r16,r4
   41d10:	1947883a 	add	r3,r3,r5
   41d14:	40c7883a 	add	r3,r8,r3
   41d18:	350d383a 	mul	r6,r6,r20
   41d1c:	1940022e 	bgeu	r3,r5,41d28 <__udivdi3+0x400>
   41d20:	01000074 	movhi	r4,1
   41d24:	310d883a 	add	r6,r6,r4
   41d28:	1828d43a 	srli	r20,r3,16
   41d2c:	a18d883a 	add	r6,r20,r6
   41d30:	81803e36 	bltu	r16,r6,41e2c <__udivdi3+0x504>
   41d34:	81803826 	beq	r16,r6,41e18 <__udivdi3+0x4f0>
   41d38:	0007883a 	mov	r3,zero
   41d3c:	003fa206 	br	41bc8 <__udivdi3+0x2a0>
   41d40:	88e2983a 	sll	r17,r17,r3
   41d44:	80a8d83a 	srl	r20,r16,r2
   41d48:	80e0983a 	sll	r16,r16,r3
   41d4c:	882ad43a 	srli	r21,r17,16
   41d50:	9884d83a 	srl	r2,r19,r2
   41d54:	a009883a 	mov	r4,r20
   41d58:	a80b883a 	mov	r5,r21
   41d5c:	142eb03a 	or	r23,r2,r16
   41d60:	98e4983a 	sll	r18,r19,r3
   41d64:	00411080 	call	41108 <__umodsi3>
   41d68:	a009883a 	mov	r4,r20
   41d6c:	a80b883a 	mov	r5,r21
   41d70:	1021883a 	mov	r16,r2
   41d74:	00410a40 	call	410a4 <__udivsi3>
   41d78:	1039883a 	mov	fp,r2
   41d7c:	8d3fffcc 	andi	r20,r17,65535
   41d80:	8020943a 	slli	r16,r16,16
   41d84:	b804d43a 	srli	r2,r23,16
   41d88:	a72d383a 	mul	r22,r20,fp
   41d8c:	1404b03a 	or	r2,r2,r16
   41d90:	1580062e 	bgeu	r2,r22,41dac <__udivdi3+0x484>
   41d94:	1445883a 	add	r2,r2,r17
   41d98:	e0ffffc4 	addi	r3,fp,-1
   41d9c:	14403836 	bltu	r2,r17,41e80 <__udivdi3+0x558>
   41da0:	1580372e 	bgeu	r2,r22,41e80 <__udivdi3+0x558>
   41da4:	e73fff84 	addi	fp,fp,-2
   41da8:	1445883a 	add	r2,r2,r17
   41dac:	15adc83a 	sub	r22,r2,r22
   41db0:	a80b883a 	mov	r5,r21
   41db4:	b009883a 	mov	r4,r22
   41db8:	00411080 	call	41108 <__umodsi3>
   41dbc:	1027883a 	mov	r19,r2
   41dc0:	b009883a 	mov	r4,r22
   41dc4:	a80b883a 	mov	r5,r21
   41dc8:	00410a40 	call	410a4 <__udivsi3>
   41dcc:	9826943a 	slli	r19,r19,16
   41dd0:	a0a1383a 	mul	r16,r20,r2
   41dd4:	b93fffcc 	andi	r4,r23,65535
   41dd8:	24c8b03a 	or	r4,r4,r19
   41ddc:	2400062e 	bgeu	r4,r16,41df8 <__udivdi3+0x4d0>
   41de0:	2449883a 	add	r4,r4,r17
   41de4:	10ffffc4 	addi	r3,r2,-1
   41de8:	24402336 	bltu	r4,r17,41e78 <__udivdi3+0x550>
   41dec:	2400222e 	bgeu	r4,r16,41e78 <__udivdi3+0x550>
   41df0:	10bfff84 	addi	r2,r2,-2
   41df4:	2449883a 	add	r4,r4,r17
   41df8:	e038943a 	slli	fp,fp,16
   41dfc:	2421c83a 	sub	r16,r4,r16
   41e00:	e086b03a 	or	r3,fp,r2
   41e04:	003f4306 	br	41b14 <__udivdi3+0x1ec>
   41e08:	2005883a 	mov	r2,r4
   41e0c:	003f6906 	br	41bb4 <__udivdi3+0x28c>
   41e10:	1805883a 	mov	r2,r3
   41e14:	003f0f06 	br	41a54 <__udivdi3+0x12c>
   41e18:	1806943a 	slli	r3,r3,16
   41e1c:	9d66983a 	sll	r19,r19,r21
   41e20:	39ffffcc 	andi	r7,r7,65535
   41e24:	19c7883a 	add	r3,r3,r7
   41e28:	98ffc32e 	bgeu	r19,r3,41d38 <__udivdi3+0x410>
   41e2c:	10bfffc4 	addi	r2,r2,-1
   41e30:	003fc106 	br	41d38 <__udivdi3+0x410>
   41e34:	00800604 	movi	r2,24
   41e38:	003f1106 	br	41a80 <__udivdi3+0x158>
   41e3c:	00800604 	movi	r2,24
   41e40:	003f2706 	br	41ae0 <__udivdi3+0x1b8>
   41e44:	00800604 	movi	r2,24
   41e48:	003ece06 	br	41984 <__udivdi3+0x5c>
   41e4c:	0007883a 	mov	r3,zero
   41e50:	00800044 	movi	r2,1
   41e54:	003f5c06 	br	41bc8 <__udivdi3+0x2a0>
   41e58:	813fa12e 	bgeu	r16,r4,41ce0 <__udivdi3+0x3b8>
   41e5c:	10bfff84 	addi	r2,r2,-2
   41e60:	85e1883a 	add	r16,r16,r23
   41e64:	003f9f06 	br	41ce4 <__udivdi3+0x3bc>
   41e68:	1c7f8a2e 	bgeu	r3,r17,41c94 <__udivdi3+0x36c>
   41e6c:	31bfff84 	addi	r6,r6,-2
   41e70:	1dc7883a 	add	r3,r3,r23
   41e74:	003f8806 	br	41c98 <__udivdi3+0x370>
   41e78:	1805883a 	mov	r2,r3
   41e7c:	003fde06 	br	41df8 <__udivdi3+0x4d0>
   41e80:	1839883a 	mov	fp,r3
   41e84:	003fc906 	br	41dac <__udivdi3+0x484>
   41e88:	b5bfff84 	addi	r22,r22,-2
   41e8c:	2449883a 	add	r4,r4,r17
   41e90:	003f3406 	br	41b64 <__udivdi3+0x23c>
   41e94:	b5bfff84 	addi	r22,r22,-2
   41e98:	1445883a 	add	r2,r2,r17
   41e9c:	003edb06 	br	41a0c <__udivdi3+0xe4>
